package types

import (
	"container/list"
	"math/big"
	"net"
	"net/http"
	"sync"
	"testing"
	"time"

	"github.com/DataDog/datadog-go/statsd"
	"github.com/btcsuite/btcd/addrmgr"
	chainlib "github.com/btcsuite/btcd/blockchain"
	"github.com/btcsuite/btcd/btcec"
	"github.com/btcsuite/btcd/chaincfg"
	"github.com/btcsuite/btcd/wire"
	"github.com/deso-protocol/core/lib"
	"github.com/deso-protocol/go-deadlock"
	merkletree "github.com/deso-protocol/go-merkle-tree"
	"github.com/dgraph-io/badger"
	"github.com/go-pg/pg"
	lru "github.com/hashicorp/golang-lru"
	"github.com/holiman/uint256"
	"github.com/kevinburke/twilio-go"
	muxtrace "gopkg.in/DataDog/dd-trace-go.v1/contrib/gorilla/mux"
	"honnef.co/go/tools/config"
)

                                      
type APIBaseResponse struct {
	// Blank if successful. Otherwise, contains a description of the
	// error that occurred.
	Error string

	// The information contained in the block’s header.
	Header *HeaderResponse

	Transactions []*TransactionResponse
} 
type APIKeyPairRequest struct {
	// A BIP39 mnemonic and extra text. Mnemonic can be 12 words or
	// 24 words. ExtraText is optional.
	Mnemonic  string
	ExtraText string

	// The index of the public/private key pair to generate
	Index uint32
} 
type APIKeyPairResponse struct {
	// Blank if successful. Otherwise, contains a description of the
	// error that occurred.
	Error string
	// The DeSo public key encoded using base58 check encoding with
	// prefix = [3]byte{0x9, 0x7f, 0x0}
	// This public key can be passed in subsequent API calls to check
	// balance, among other things. All encoded DeSo public keys start
	// with the characters “BC”
	PublicKeyBase58Check string
	// The DeSo public key encoded as a plain hex string. This should
	// match the public key with the corresponding index generated by this tool.
	// This should not be passed to subsequent API calls, it is only provided
	// as a reference, mainly as a sanity-check.
	PublicKeyHex string
	// The DeSo private key encoded using base58 check encoding with
	// prefix = [3]byte{0x50, 0xd5, 0x0}
	// This private key can be passed in subsequent API calls to spend DeSo,
	// among other things. All DeSo private keys start with
	// the characters “bc”
	PrivateKeyBase58Check string
	// The DeSo private key encoded as a plain hex string. Note that
	// this will not directly match what is produced by the tool because the
	// tool shows the private key encoded using Bitcoin’s WIF format rather
	// than as raw hex. To convert this raw hex into Bitcoin’s WIF format you can
	// use this simple Python script. This should not be passed to subsequent
	// API calls, it is only provided as a reference, mainly as a sanity-check.
	PrivateKeyHex string
} 
type APIBalanceRequest struct {
	PublicKeyBase58Check string
	Confirmations        uint32
} 
type UTXOEntryResponse struct {
	// A string that uniquely identifies a previous transaction. This is
	// a sha256 hash of the transaction’s information encoded using
	// base58 check encoding.
	TransactionIDBase58Check string
	// The index within this transaction that corresponds to an output
	// spendable by the passed-in public key.
	Index int64
	// The amount that is spendable by this UTXO in “nanos”.
	AmountNanos uint64
	// The pulic key entitled to spend the amount stored in this UTXO.
	PublicKeyBase58Check string
	// The number of confirmations this UTXO has. Set to zero if the
	// UTXO is unconfirmed.
	Confirmations int64
	// Whether or not this UTXO was a block reward.
	UtxoType string

	BlockHeight int64
} 
type APIBalanceResponse struct {
	// Blank if successful. Otherwise, contains a description of the
	// error that occurred.
	Error string
	// The balance of the public key queried in “nanos.” Note
	// there are 1e9 “nanos” per DeSo, so if the balance were “1 DeSo” then
	// this value would be set to 1e9.
	ConfirmedBalanceNanos int64
	// The unconfirmed balance of the public key queried in “nanos.” This field
	// is set to zero if Confirmations is set to a value greater than zero.
	UnconfirmedBalanceNanos int64
	// DeSo uses a UTXO model similar to Bitcoin. As such, querying
	// the balance returns all of the UTXOs for a particular public key for
	// convenience. Note that a UTXO is simply a reference to a particular
	// output index in a previous transaction
	UTXOs []*UTXOEntryResponse
} 
type InputResponse struct {
	TransactionIDBase58Check string
	Index                    int64
} 
type OutputResponse struct {
	PublicKeyBase58Check string
	AmountNanos          uint64
} 
type TransactionResponse struct {
	// A string that uniquely identifies this transaction. This is a sha256 hash
	// of the transaction’s data encoded using base58 check encoding.
	TransactionIDBase58Check string
	// The raw hex of the transaction data. This can be fully-constructed from
	// the human-readable portions of this object.
	RawTransactionHex string `json:",omitempty"`
	// The inputs and outputs for this transaction.
	Inputs  []*InputResponse  `json:",omitempty"`
	Outputs []*OutputResponse `json:",omitempty"`
	// The signature of the transaction in hex format.
	SignatureHex string `json:",omitempty"`
	// Will always be “0” for basic transfers
	TransactionType string `json:",omitempty"`
	// TODO: Create a TransactionMeta portion for the response.

	// The hash of the block in which this transaction was mined. If the
	// transaction is unconfirmed, this field will be empty. To look up
	// how many confirmations a transaction has, simply plug this value
	// into the "block" endpoint.
	BlockHashHex string `json:",omitempty"`

	TransactionMetadata TransactionMetadata `json:",omitempty"`

	// The ExtraData added to this transaction
	ExtraData map[string]string `json:",omitempty"`
} 
type TransactionInfoResponse struct {
	// The sum of the inputs
	TotalInputNanos uint64
	// The amount being sent to the “RecipientPublicKeyBase58Check”
	SpendAmountNanos uint64
	// The amount being returned to the “SenderPublicKeyBase58Check”
	ChangeAmountNanos uint64
	// The total fee and the fee rate (in nanos per KB) that was used for this
	// transaction.
	FeeNanos          uint64
	FeeRateNanosPerKB uint64
	// Will match the public keys passed as params. Note that
	// SenderPublicKeyBase58Check receives the change from this transaction.
	SenderPublicKeyBase58Check    string
	RecipientPublicKeyBase58Check string
} 
type APITransferDeSoRequest struct {
	// An DeSo private key encoded using base58 check encoding (starts
	// with "bc").
	SenderPrivateKeyBase58Check string
	// An DeSo public key encoded using base58 check encoding (starts
	// with “BC”) that will receive the DeSo being sent. This field is required
	// whether sending using an explicit public/private key pair.
	RecipientPublicKeyBase58Check string
	// The amount of DeSo to send in “nanos.” Note that “1 DeSo” is equal to
	// 1e9 nanos, so to send 1 DeSo, this value would need to be set to 1e9.
	AmountNanos int64
	// The fee rate to use for this transaction. If left unset, a default fee rate
	// will be used. This can be checked using the “DryRun” parameter below.
	MinFeeRateNanosPerKB int64

	// No need to specify ProfileEntryResponse in each TransactionFee
	TransactionFees []TransactionFee `safeForLogging:"true"`

	// When set to true, the transaction is returned in the response but not
	// actually broadcast to the network. Useful for testing.
	DryRun bool
} 
type APITransferDeSoResponse struct {
	// Blank if successful. Otherwise, contains a description of the
	// error that occurred.
	Error string

	// The transaction we assembled.
	Transaction *TransactionResponse

	// Information about the transaction that we compute for
	// convenience.
	TransactionInfo *TransactionInfoResponse
} 
type APITransactionInfoRequest struct {
	// When set to true, the response simply contains all transactions in the
	// mempool with no filtering.
	IsMempool bool

	// A string that uniquely identifies this transaction. E.g. from a previous
	// call to “transfer-deso”. Ignored when PublicKeyBase58Check is set.
	TransactionIDBase58Check string

	// An DeSo public key encoded using base58 check encoding (starts
	// with “BC”) to get transaction IDs for. When set,
	// TransactionIDBase58Check is ignored.
	PublicKeyBase58Check string

	// Only return transaction IDs
	IDsOnly bool

	// Offset from which a page should be fetched
	LastTransactionIDBase58Check string

	// The last index of a transaction for a public key seen. If less than 0, it means we are not looking at
	// transactions in the database yet.
	LastPublicKeyTransactionIndex int64

	// Number of transactions to be returned
	Limit uint64
} 
type APITransactionInfoResponse struct {
	// Blank if successful. Otherwise, contains a description of the
	// error that occurred.
	Error string

	// The info for all transactions this public key is associated with from oldest
	// to newest.
	Transactions []*TransactionResponse

	// The hash of the last transaction
	LastTransactionIDBase58Check string

	// The last index of a transaction for a public key seen.
	LastPublicKeyTransactionIndex int64

	BalanceNanos uint64
} 
type APINodeInfoRequest struct {
} 
type APINodeInfoResponse struct {
	// Blank if successful. Otherwise, contains a description of the
	// error that occurred.
	Error string
} 
type APIBlockRequest struct {
	// Block height. 0 corresponds to the genesis block. An error will be
	// returned if the height exceeds the tip. This field is ignored if HashHex is
	// set.
	Height int64
	// Hash of the block to return. Height is ignored if this is set.
	HashHex string
	// When set to false, only returns the header of the block requested
	// not the full block. Otherwise, returns the full block.
	FullBlock bool
} 
type HeaderResponse struct {
	// The hash of the block that was queried.
	BlockHashHex string
	// Generally set to zero
	Version uint32
	// Hash of the previous block in the chain.
	PrevBlockHashHex string
	// The merkle root of all the transactions contained within the block.
	TransactionMerkleRootHex string
	// The unix timestamp (in seconds) specifying when this block was
	// mined.
	TstampSecs uint64
	// The height of the block this header corresponds to.
	Height uint64

	// The Nonce and ExtraNonce combine to give miners 128 bits of entropy
	Nonce      uint64
	ExtraNonce uint64
} 
type APIBlockResponse struct {
	// Blank if successful. Otherwise, contains a description of the
	// error that occurred.
	Error string

	// The information contained in the block’s header.
	Header *HeaderResponse

	Transactions []*TransactionResponse
} 
type APIServer struct {
	backendServer Server
	mempool       DeSoMempool
	blockchain    Blockchain
	blockProducer DeSoBlockProducer
	Params        DeSoParams
	Config        *config.Config

	MinFeeRateNanosPerKB uint64

	// A pointer to the router that handles all requests.
	router *muxtrace.Router

	TXIndex TXIndex

	// Used for getting/setting the global state. Usually either a db is set OR
	// a remote node is set-- not both. When a remote node is set, global state
	// is set and fetched from that node. Otherwise, it is set/fetched from the
	// db. This makes it easy to run a local node in development.
	GlobalState *GlobalState

	// Optional, may be empty. Used for Twilio integration
	Twilio *twilio.Client

	// When set, BlockCypher is used to add extra security to BitcoinExchange
	// transactions.
	BlockCypherAPIKey string

	// This lock is used when sending seed DeSo to avoid a race condition
	// in which two calls to sending the seed DeSo use the same UTXO,
	// causing one to error.
	mtxSeedDeSo sync.RWMutex

	UsdCentsPerDeSoExchangeRate    uint64
	UsdCentsPerBitCoinExchangeRate float64
	UsdCentsPerETHExchangeRate     uint64

	// List of prices retrieved.  This is culled everytime we update the current price.
	LastTradeDeSoPriceHistory []LastTradePriceHistoryItem
	// How far back do we consider trade prices when we set the current price of $DESO in nanoseconds
	LastTradePriceLookback uint64

	// Base-58 prefix to check for to determine if a string could be a public key.
	PublicKeyBase58Prefix string

	// A list of posts from the last 24hrs ordered by hotness score.
	HotFeedOrderedList []*HotFeedEntry
	// The height of the last block evaluated by the hotness routine.
	HotFeedBlockHeight uint32
	// Map of whitelisted post hashes used for serving the hot feed.
	// The float64 value is a multiplier than can be modified and used in scoring.
	HotFeedApprovedPostsToMultipliers             map[lib.BlockHash]float64
	LastHotFeedApprovedPostOpProcessedTstampNanos uint64
	// Multipliers applied to individual PKIDs to help node operators better fit their
	// hot feed to the type of content they would like to display.
	HotFeedPKIDMultipliers                          map[lib.PKID]*HotFeedPKIDMultiplier
	LastHotFeedPKIDMultiplierOpProcessedTstampNanos uint64
	// Constants for the hotness score algorithm.
	HotFeedInteractionCap        uint64
	HotFeedTimeDecayBlocks       uint64
	HotFeedPostMultiplierUpdated bool
	HotFeedPKIDMultiplierUpdated bool

	//Map of transaction type to []DeSoOutput that represent fees assessed on each transaction of that type.
	TransactionFeeMap map[lib.TxnType][]DeSoOutput

	// Map of public keys that are exempt from node fees
	ExemptPublicKeyMap map[string]interface{}

	// Global State cache

	// VerifiedUsernameToPKIDMap is a map of lowercase usernames to PKIDs representing the current state of
	// verifications this node is recognizing.
	VerifiedUsernameToPKIDMap map[string]PKID
	// BlacklistedPKIDMap is a map of PKID to a byte slice representing the PKID of a user as the key and the current
	// blacklist state of that user as the key. If a PKID is not present in this map, then the user is NOT blacklisted.
	BlacklistedPKIDMap map[lib.PKID][]byte
	// BlacklistedResponseMap is a map of PKIDs converted to base58-encoded string to a byte slice. This is computed
	// from the BlacklistedPKIDMap above and is a JSON-encodable version of that map. This map is only used when
	// responding to requests for this node's blacklist. A JSON-encoded response is easier for any language to digest
	// than a gob-encoded one.
	BlacklistedResponseMap map[string][]byte
	// GraylistedPKIDMap is a map of PKID to a byte slice representing the PKID of a user as the key and the current
	// graylist state of that user as the key. If a PKID is not present in this map, then the user is NOT graylisted.
	GraylistedPKIDMap map[lib.PKID][]byte
	// GraylistedResponseMap is a map of PKIDs converted to base58-encoded string to a byte slice. This is computed
	// from the GraylistedPKIDMap above and is a JSON-encodable version of that map. This map is only used when
	// responding to requests for this node's graylist. A JSON-encoded response is easier for any language to digest
	// than a gob-encoded one.
	GraylistedResponseMap map[string][]byte
	// GlobalFeedPostHashes is a slice of BlockHashes representing the state of posts on the global feed on this node.
	GlobalFeedPostHashes []BlockHash

	// Cache of Total Supply and Rich List
	TotalSupplyNanos  uint64
	TotalSupplyDESO   float64
	RichList          []RichListEntryResponse
	CountKeysWithDESO uint64

	// map of country name to sign up bonus data
	AllCountryLevelSignUpBonuses map[string]CountrySignUpBonusResponse

	// Frequently accessed data from global state
	USDCentsToDESOReserveExchangeRate uint64
	BuyDESOFeeBasisPoints uint64
	JumioUSDCents uint64
	JumioKickbackUSDCents uint64

	// Signals that the frontend server is in a stopped state
	quit chan struct{}
} 
type LastTradePriceHistoryItem struct {
	LastTradePrice uint64
	Timestamp      uint64
} 
type Route struct {
	Name        string
	Method      []string
	Pattern     string
	HandlerFunc http.HandlerFunc
	AccessLevel AccessLevel
} 
type AdminRequest struct {
	JWT            string
	AdminPublicKey string
} 
type AmplitudeUploadRequestBody struct {
	ApiKey string           `json:"api_key"`
	Events []AmplitudeEvent `json:"events"`
} 
type AmplitudeEvent struct {
	UserId          string                 `json:"user_id"`
	EventType       string                 `json:"event_type"`
	EventProperties map[string]interface{} `json:"event_properties"`
} 
type AccessLevel int
 
type AdminCreateReferralHashRequest struct {
	// A username or public name can be provided. If both are provided, public key is used.
	UserPublicKeyBase58Check string `safeForLogging:"true"`
	Username                 string `safeForLogging:"true"`

	// ReferralInfo to add for the new referral hash.
	ReferrerAmountUSDCents uint64 `safeForLogging:"true"`
	RefereeAmountUSDCents  uint64 `safeForLogging:"true"`
	MaxReferrals           uint64 `safeForLogging:"true"`
	RequiresJumio          bool   `safeForLogging:"true"`

	AdminPublicKey string `safeForLogging:"true"`
} 
type AdminCreateReferralHashResponse struct {
	ReferralInfoResponse ReferralInfoResponse `safeForLogging:"true"`
} 
type AdminUpdateReferralHashRequest struct {
	// Referral hash to update.
	ReferralHashBase58 string `safeForLogging:"true"`

	// ReferralInfo to updatethe referral hash with.
	ReferrerAmountUSDCents uint64 `safeForLogging:"true"`
	RefereeAmountUSDCents  uint64 `safeForLogging:"true"`
	MaxReferrals           uint64 `safeForLogging:"true"`
	RequiresJumio          bool   `safeForLogging:"true"`
	IsActive               bool   `safeForLogging:"true"`

	AdminPublicKey string `safeForLogging:"true"`
} 
type AdminUpdateReferralHashResponse struct {
	ReferralInfoResponse ReferralInfoResponse `safeForLogging:"true"`
} 
type ReferralInfoResponse struct {
	IsActive      bool
	Info          ReferralInfo
	ReferredUsers []ProfileEntryResponse
} 
type SimpleReferralInfoResponse struct {
	IsActive bool
	Info     SimpleReferralInfo
} 
type AdminGetAllReferralInfoForUserRequest struct {
	// A username or public name can be provided. If both are provided, public key is used.
	UserPublicKeyBase58Check string `safeForLogging:"true"`
	Username                 string `safeForLogging:"true"`

	AdminPublicKey string `safeForLogging:"true"`
} 
type AdminGetAllReferralInfoForUserResponse struct {
	ReferralInfoResponses []ReferralInfoResponse `safeForLogging:"true"`
} 
type AdminDownloadReferralCSVResponse struct {
	CSVRows [][]string
} 
type AdminUploadReferralCSVRequest struct {
	CSVRows [][]string
} 
type AdminUploadReferralCSVResponse struct {
	LinksCreated uint64
	LinksUpdated uint64
} 
type AdminDownloadRefereeCSVResponse struct {
	CSVRows [][]string
} 
type AdminGetNFTDropRequest struct {
	// "-1" is used to request the next planned drop.
	DropNumber int `safeForLogging:"true"`
} 
type AdminGetNFTDropResponse struct {
	DropEntry *NFTDropEntry
	Posts     []*PostEntryResponse
} 
type AdminUpdateNFTDropRequest struct {
	DropNumber         int    `safeForLogging:"true"`
	DropTstampNanos    int    `safeForLogging:"true"`
	IsActive           bool   `safeForLogging:"true"`
	NFTHashHexToAdd    string `safeForLogging:"true"`
	NFTHashHexToRemove string `safeForLogging:"true"`
} 
type AdminUpdateNFTDropResponse struct {
	DropEntry *NFTDropEntry
	Posts     []*PostEntryResponse
} 
type AdminPinPostRequest struct {
	// The post hash of the post to pin or unpin from the global feed
	PostHashHex string `safeForLogging:"true"`
	// If true, remove the given post hash hex from the list of pinned posts
	UnpinPost bool `safeForLogging:"true"`
} 
type AdminUpdateGlobalFeedRequest struct {
	// The post hash of the post to add or remove from the global feed.
	PostHashHex string `safeForLogging:"true"`
	// If true, remove the given post hash hex from the global feed.
	RemoveFromGlobalFeed bool `safeForLogging:"true"`
} 
type AdminRemoveNilPostsRequest struct {
	// Number of posts to try to fetch from global state, starting from the most recent post
	// added to the global feed.
	NumPostsToSearch int `safeForLogging:"true"`
} 
type AdminResetJumioRequest struct {
	PublicKeyBase58Check string
	Username             string
	JWT                  string
} 
type AdminUpdateJumioDeSoRequest struct {
	JWT       string
	DeSoNanos uint64
} 
type AdminUpdateJumioDeSoResponse struct {
	DeSoNanos uint64
} 
type AdminUpdateJumioUSDCentsRequest struct {
	JWT      string
	USDCents uint64
} 
type AdminUpdateJumioUSDCentsResponse struct {
	USDCents uint64
} 
type AdminUpdateJumioKickbackUSDCentsRequest struct {
	JWT      string
	USDCents uint64
} 
type AdminUpdateJumioKickbackUSDCentsResponse struct {
	USDCents uint64
} 
type AdminSetJumioVerifiedRequest struct {
	PublicKeyBase58Check string
	Username             string
} 
type AdminJumioCallback struct {
	PublicKeyBase58Check string
	Username             string
	CountryAlpha3        string
} 
type AdminUpdateJumioCountrySignUpBonusRequest struct {
	CountryCode             string
	CountryLevelSignUpBonus CountryLevelSignUpBonus
} 
type GetAllCountryLevelSignUpBonusResponse struct {
	SignUpBonusMetadata        map[string]CountrySignUpBonusResponse
	DefaultSignUpBonusMetadata CountryLevelSignUpBonus
} 
type CountrySignUpBonusResponse struct {
	CountryLevelSignUpBonus CountryLevelSignUpBonus
	CountryCodeDetails      Alpha3CountryCodeDetails
} 
type AdminUpdateTutorialCreatorRequest struct {
	PublicKeyBase58Check string
	IsRemoval            bool
	IsWellKnown          bool
	JWT                  string
} 
type AdminResetTutorialStatusRequest struct {
	PublicKeyBase58Check string
} 
type AdminUpdateUserGlobalMetadataRequest struct {
	// The public key of the user to update. This will trump 'Username' if both are provided.
	UserPublicKeyBase58Check string `safeForLogging:"true"`
	// The username associated with the public key to update.
	Username string `safeForLogging:"true"`

	// Whether this is a blacklist update or not.
	IsBlacklistUpdate bool `safeForLogging:"true"`
	// Set to true if this user's content should not show up anywhere on the site.
	// Only set if IsBlacklistUpdate == true.
	RemoveEverywhere bool `safeForLogging:"true"`
	// Should be set to true if this user should not show up on the creator leaderboard.
	// Only set if IsBlacklistUpdate == true.
	RemoveFromLeaderboard bool `safeForLogging:"true"`

	// Whether this is a whitelist update or not.
	IsWhitelistUpdate bool `safeForLogging:"true"`
	// Set to true to automatically show this users posts in the global feed (max 5 per day).
	WhitelistPosts bool `safeForLogging:"true"`

	// Remove PhoneNumberMetadata to allow re-registration
	RemovePhoneNumberMetadata bool `safeForLogging:"true"`

	AdminPublicKey string
} 
type AdminGetAllUserGlobalMetadataRequest struct {
	NumToFetch int `safeForLogging:"true"`
} 
type AdminGetAllUserGlobalMetadataResponse struct {
	// A mapping between the PublicKeyBase58Check string and the user's global metadata.
	PubKeyToUserGlobalMetadata map[string]*UserMetadata
	PubKeyToUsername           map[string]string
} 
type AdminGetUserGlobalMetadataRequest struct {
	UserPublicKeyBase58Check string `safeForLogging:"true"`
} 
type AdminGetUserGlobalMetadataResponse struct {
	// the user's global metadata.
	UserMetadata UserMetadata

	// The User object
	UserProfileEntryResponse *ProfileEntryResponse
} 
type VerifiedUsernameToPKID struct {
	VerifiedUsernameToPKID map[string]PKID
} 
type VerificationUsernameAuditLog struct {
	// Time at which the verification was granted or removed.
	TimestampNanos uint64
	// Username and PKID of the admin who verified the user.
	VerifierUsername string
	VerifierPKID     PKID
	// The user who was verified or had their verification removed.
	VerifiedUsername string
	VerifiedPKID     PKID
	// Indicator of whether this request granted verification or removed verification.
	IsRemoval bool
} 
type FilterAuditLog struct {
	// Time at which the filter status was granted or removed.
	TimestampNanos uint64
	// The filter type being updated
	Filter FilterType
	// Username and PKID of the admin who filtered the user.
	UpdaterUsername string
	UpdaterPKID     PKID
	// The user who was filtered or had their filter removed.
	UpdatedUsername string
	UpdatedPKID     PKID
	// Indicator of whether this request granted the filter status or removed it.
	IsRemoval bool
} 
type AdminGrantVerificationBadgeRequest struct {
	UsernameToVerify string `safeForLogging:"true"`
	AdminPublicKey   string
} 
type AdminGrantVerificationBadgeResponse struct {
	Message string
} 
type AdminRemoveVerificationBadgeRequest struct {
	UsernameForWhomToRemoveVerification string `safeForLogging:"true"`
	AdminPublicKey                      string
} 
type AdminRemoveVerificationBadgeResponse struct {
	Message string
} 
type AdminGetVerifiedUsersResponse struct {
	VerifiedUsers []string
} 
type VerificationUsernameAuditLogResponse struct {
	TimestampNanos               uint64
	VerifierUsername             string
	VerifierPublicKeyBase58Check string
	VerifiedUsername             string
	VerifiedPublicKeyBase58Check string
	IsRemoval                    bool
} 
type AdminGetUsernameVerificationAuditLogsRequest struct {
	Username string
} 
type AdminGetUsernameVerificationAuditLogsResponse struct {
	VerificationAuditLogs []VerificationUsernameAuditLogResponse
} 
type AdminGetUserAdminDataRequest struct {
	UserPublicKeyBase58Check string
} 
type AdminGetUserAdminDataResponse struct {
	// Profile Data
	Username string

	// Verifiers
	IsVerified                 bool
	LastVerifierPublicKey      string
	LastVerifyRemoverPublicKey string

	// White/Gray/Black list
	IsWhitelisted                 bool
	LastWhitelisterPublicKey      string
	LastWhitelistRemoverPublicKey string
	IsGraylisted                  bool
	LastGraylisterPublicKey       string
	LastGraylistRemoverPublicKey  string
	IsBlacklisted                 bool
	LastBlacklisterPublicKey      string
	LastBlacklistRemoverPublicKey string

	// Phone number verification
	PhoneNumber string
	Email       string

	// Referral Code
	ReferralHashBase58Check            string
	JumioStarterDeSoTxnHashBase58Check string
	ReferrerDeSoTxnHashBase58Check     string
} 
type FilterType uint32
 
type AffectedPublicKey struct {
	PublicKeyBase58Check string
	// Metadata about how this public key was affected by the transaction.
	Metadata string
} 
type BasicTransferTxindexMetadata struct {
	TotalInputNanos  uint64
	TotalOutputNanos uint64
	FeeNanos         uint64
	UtxoOpsDump      string
	UtxoOps          []*UtxoOperation
	DiamondLevel     int64
	PostHashHex      string
} 
type BitcoinExchangeTxindexMetadata struct {
	BitcoinSpendAddress string
	// DeSoOutputPubKeyBase58Check = TransactorPublicKeyBase58Check
	SatoshisBurned uint64
	// NanosCreated = 0 OR TotalOutputNanos+FeeNanos
	NanosCreated uint64
	// TotalNanosPurchasedBefore = TotalNanosPurchasedAfter - NanosCreated
	TotalNanosPurchasedBefore uint64
	TotalNanosPurchasedAfter  uint64
	BitcoinTxnHash            string
} 
type CreatorCoinTxindexMetadata struct {
	OperationType string
	// TransactorPublicKeyBase58Check = TransactorPublicKeyBase58Check
	// CreatorPublicKeyBase58Check in AffectedPublicKeys

	// Differs depending on OperationType.
	DeSoToSellNanos        uint64
	CreatorCoinToSellNanos uint64
	DeSoToAddNanos         uint64

	// Rosetta needs to know how much DESO was added or removed so it can
	// model the change to the total deso locked in the creator coin
	DESOLockedNanosDiff int64
} 
type CreatorCoinTransferTxindexMetadata struct {
	CreatorUsername            string
	CreatorCoinToTransferNanos uint64
	DiamondLevel               int64
	PostHashHex                string
} 
type DAOCoinTransferTxindexMetadata struct {
	CreatorUsername        string
	DAOCoinToTransferNanos uint256.Int
} 
type DAOCoinTxindexMetadata struct {
	CreatorUsername           string
	OperationType             string
	CoinsToMintNanos          uint256.Int
	CoinsToBurnNanos          uint256.Int
	TransferRestrictionStatus string
} 
type UpdateProfileTxindexMetadata struct {
	ProfilePublicKeyBase58Check string

	NewUsername    string
	NewDescription string
	NewProfilePic  string

	NewCreatorBasisPoints uint64

	NewStakeMultipleBasisPoints uint64

	IsHidden bool
} 
type SubmitPostTxindexMetadata struct {
	PostHashBeingModifiedHex string
	// PosterPublicKeyBase58Check = TransactorPublicKeyBase58Check

	// If this is a reply to an existing post, then the ParentPostHashHex
	ParentPostHashHex string
	// ParentPosterPublicKeyBase58Check in AffectedPublicKeys

	// The profiles that are mentioned are in the AffectedPublicKeys
	// MentionedPublicKeyBase58Check in AffectedPublicKeys
} 
type LikeTxindexMetadata struct {
	// LikerPublicKeyBase58Check = TransactorPublicKeyBase58Check
	IsUnlike bool

	PostHashHex string
	// PosterPublicKeyBase58Check in AffectedPublicKeys
} 
type FollowTxindexMetadata struct {
	// FollowerPublicKeyBase58Check = TransactorPublicKeyBase58Check
	// FollowedPublicKeyBase58Check in AffectedPublicKeys

	IsUnfollow bool
} 
type PrivateMessageTxindexMetadata struct {
	// SenderPublicKeyBase58Check = TransactorPublicKeyBase58Check
	// RecipientPublicKeyBase58Check in AffectedPublicKeys

	TimestampNanos uint64
} 
type SwapIdentityTxindexMetadata struct {
	// ParamUpdater = TransactorPublicKeyBase58Check

	FromPublicKeyBase58Check string
	ToPublicKeyBase58Check   string

	// Rosetta needs this information to track creator coin balances
	FromDeSoLockedNanos uint64
	ToDeSoLockedNanos   uint64
} 
type NFTRoyaltiesMetadata struct {
	CreatorCoinRoyaltyNanos     uint64
	CreatorRoyaltyNanos         uint64
	CreatorPublicKeyBase58Check string
	// We omit the maps when empty to save some space.
	AdditionalCoinRoyaltiesMap map[string]uint64 `json:",omitempty"`
	AdditionalDESORoyaltiesMap map[string]uint64 `json:",omitempty"`
} 
type NFTBidTxindexMetadata struct {
	NFTPostHashHex            string
	SerialNumber              uint64
	BidAmountNanos            uint64
	IsBuyNowBid               bool
	OwnerPublicKeyBase58Check string
	// We omit the empty object here as a bid that doesn't trigger a "buy now" operation will have no royalty metadata
	NFTRoyaltiesMetadata `json:",omitempty"`
} 
type AcceptNFTBidTxindexMetadata struct {
	NFTPostHashHex string
	SerialNumber   uint64
	BidAmountNanos uint64
	NFTRoyaltiesMetadata
} 
type NFTTransferTxindexMetadata struct {
	NFTPostHashHex string
	SerialNumber   uint64
} 
type AcceptNFTTransferTxindexMetadata struct {
	NFTPostHashHex string
	SerialNumber   uint64
} 
type BurnNFTTxindexMetadata struct {
	NFTPostHashHex string
	SerialNumber   uint64
} 
type CreateNFTTxindexMetadata struct {
	NFTPostHashHex             string
	AdditionalCoinRoyaltiesMap map[string]uint64 `json:",omitempty"`
	AdditionalDESORoyaltiesMap map[string]uint64 `json:",omitempty"`
} 
type UpdateNFTTxindexMetadata struct {
	NFTPostHashHex string
	IsForSale      bool
} 
type TransactionMetadata struct {
	BlockHashHex    string
	TxnIndexInBlock uint64
	TxnType         string
	// All transactions have a public key who executed the transaction and some
	// public keys that are affected by the transaction. Notifications are created
	// for the affected public keys. _getPublicKeysForTxn uses this to set entries in the
	// database.
	TransactorPublicKeyBase58Check string
	AffectedPublicKeys             []*AffectedPublicKey

	// We store these outputs so we don't have to load the full transaction from disk
	// when looking up output amounts
	TxnOutputs []*DeSoOutput

	BasicTransferTxindexMetadata       *BasicTransferTxindexMetadata       `json:",omitempty"`
	BitcoinExchangeTxindexMetadata     *BitcoinExchangeTxindexMetadata     `json:",omitempty"`
	CreatorCoinTxindexMetadata         *CreatorCoinTxindexMetadata         `json:",omitempty"`
	CreatorCoinTransferTxindexMetadata *CreatorCoinTransferTxindexMetadata `json:",omitempty"`
	UpdateProfileTxindexMetadata       *UpdateProfileTxindexMetadata       `json:",omitempty"`
	SubmitPostTxindexMetadata          *SubmitPostTxindexMetadata          `json:",omitempty"`
	LikeTxindexMetadata                *LikeTxindexMetadata                `json:",omitempty"`
	FollowTxindexMetadata              *FollowTxindexMetadata              `json:",omitempty"`
	PrivateMessageTxindexMetadata      *PrivateMessageTxindexMetadata      `json:",omitempty"`
	SwapIdentityTxindexMetadata        *SwapIdentityTxindexMetadata        `json:",omitempty"`
	NFTBidTxindexMetadata              *NFTBidTxindexMetadata              `json:",omitempty"`
	AcceptNFTBidTxindexMetadata        *AcceptNFTBidTxindexMetadata        `json:",omitempty"`
	NFTTransferTxindexMetadata         *NFTTransferTxindexMetadata         `json:",omitempty"`
	AcceptNFTTransferTxindexMetadata   *AcceptNFTTransferTxindexMetadata   `json:",omitempty"`
	BurnNFTTxindexMetadata             *BurnNFTTxindexMetadata             `json:",omitempty"`
	DAOCoinTxindexMetadata             *DAOCoinTxindexMetadata             `json:",omitempty"`
	DAOCoinTransferTxindexMetadata     *DAOCoinTransferTxindexMetadata     `json:",omitempty"`
	CreateNFTTxindexMetadata           *CreateNFTTxindexMetadata           `json:",omitempty"`
	UpdateNFTTxindexMetadata           *UpdateNFTTxindexMetadata           `json:",omitempty"`
} 
type ChainType uint8
 
type Alpha3CountryCodeDetails struct {
	CountryCode string
	Name        string
	Alpha3      string
} 
type BitcoinUtxo struct {
	TxID           int64
	Index          int64
	AmountSatoshis int64
} 
type BlockCypherAPIInputResponse struct {
	PrevTxIDHex    string   `json:"prev_hash"`
	Index          int64    `json:"output_index"`
	ScriptHex      string   `json:"script"`
	AmountSatoshis int64    `json:"output_value"`
	Sequence       int64    `json:"sequence"`
	Addresses      []string `json:"addresses"`
	ScriptType     string   `json:"script_type"`
	Age            int64    `json:"age"`
} 
type BlockCypherAPIOutputResponse struct {
	AmountSatoshis int64    `json:"value"`
	ScriptHex      string   `json:"script"`
	Addresses      []string `json:"addresses"`
	ScriptType     string   `json:"script_type"`
	SpentBy        string   `json:"spent_by"`
} 
type BlockCypherAPITxnResponse struct {
	BlockHashHex  string                          `json:"block_hash"`
	BlockHeight   int64                           `json:"block_height"`
	LockTime      int64                           `json:"lock_time"`
	TxIDHex       string                          `json:"hash"`
	Inputs        []*BlockCypherAPIInputResponse  `json:"inputs"`
	Outputs       []*BlockCypherAPIOutputResponse `json:"outputs"`
	Confirmations int64                           `json:"confirmations"`
	DoubleSpend   bool                            `json:"double_spend"`
} 
type BlockCypherAPIFullAddressResponse struct {
	Address string `json:"address"`
	// Balance data
	ConfirmedBalance   int64 `json:"balance"`
	UnconfirmedBalance int64 `json:"unconfirmed_balance"`
	FinalBalance       int64 `json:"final_balance"`

	// Transaction data
	Txns []*BlockCypherAPITxnResponse `json:"txs"`

	HasMore bool `json:"hasMore"`

	Error string `json:"error"`
} 
type BlockchainInfoAPIResponse struct {
	DoubleSpend bool `json:"double_spend"`
} 
type BlockonomicsRBFResponse struct {
	RBF    int64  `json:"rbf"`
	Status string `json:"status"`
} 
type BlockNode struct {
	// Pointer to a node representing the block's parent.
	Parent *BlockNode

	// The hash computed on this block.
	Hash *BlockHash

	// Height is the position in the block chain.
	Height uint32

	// The difficulty target for this block. Used to compute the next
	// block's difficulty target so it can be validated.
	DifficultyTarget *BlockHash

	// A computation of the total amount of work that has been performed
	// on this chain, including the current node.
	CumWork *big.Int

	// The block header.
	Header *MsgDeSoHeader

	// Status holds the validation state for the block and whether or not
	// it's stored in the database.
	Status BlockStatus
} 
type OrphanBlock struct {
	Block *MsgDeSoBlock
	Hash  *BlockHash
} 
type Blockchain struct {
	db                              *badger.DB
	postgres                        *Postgres
	timeSource                      chainlib.MedianTimeSource
	trustedBlockProducerPublicKeys  map[PkMapKey]bool
	trustedBlockProducerStartHeight uint64
	params                          *DeSoParams
	eventManager                    *EventManager
	// Returns true once all of the housekeeping in creating the
	// blockchain is complete. This includes setting up the genesis block.
	isInitialized bool

	// Protects most of the fields below this point.
	ChainLock deadlock.RWMutex

	// These should only be accessed after acquiring the ChainLock.
	//
	// An in-memory index of the "tree" of blocks we are currently aware of.
	// This index includes forks and side-chains but does not include unconnectedTxns.
	blockIndex map[BlockHash]*BlockNode
	// An in-memory slice of the blocks on the main chain only. The end of
	// this slice is the best known tip that we have at any given time.
	bestChain    []*BlockNode
	bestChainMap map[BlockHash]*BlockNode

	bestHeaderChain    []*BlockNode
	bestHeaderChainMap map[BlockHash]*BlockNode

	// We keep track of orphan blocks with the following data structures. Orphans
	// are not written to disk and are only cached in memory. Moreover we only keep
	// up to MaxOrphansInMemory of them in order to prevent memory exhaustion.
	orphanList *list.List
} 
type BlockStatus uint32
 
type SyncState uint8
 
type CoinbaseResponse struct {
	Data struct {
		Amount string `json:"amount"`
	} `json:"data"`
} 
type CoingeckoResponse struct {
	Bitcoin struct {
		USD float64 `json:"usd"`
	} `json:"bitcoin"`
} 
type BlockchainDotcomResponse struct {
	USD struct {
		FifteenMinutePrice float64 `json:"15m"`
	} `json:"USD"`
} 
type GeminiResponse struct {
	Last string `json:"last"`
} 
type KrakenResponse struct {
	Result struct {
		Ticker struct {
			LastPriceList []string `json:"c"`
		} `json:"XXBTZUSD"`
	} `json:"result"`
} 
type ConnectionManager struct {
	// Keep a reference to the Server.
	// TODO: I'm pretty sure we can make it so that the ConnectionManager and the Peer
	// doesn't need a reference to the Server object. But for now we keep things lazy.
	srv *Server

	// When --connectips is set, we don't connect to anything from the addrmgr.
	connectIps []string

	// The address manager keeps track of peer addresses we're aware of. When
	// we need to connect to a new outbound peer, it chooses one of the addresses
	// it's aware of at random and provides it to us.
	addrMgr *addrmgr.AddrManager
	// The interfaces we listen on for new incoming connections.
	listeners []net.Listener
	// The parameters we are initialized with.
	params *DeSoParams
	// The target number of outbound peers we want to have.
	targetOutboundPeers uint32
	// The maximum number of inbound peers we allow.
	maxInboundPeers uint32
	// When true, only one connection per IP is allowed. Prevents eclipse attacks
	// among other things.
	limitOneInboundConnectionPerIP bool

	// Keep track of the nonces we've sent in our version messages so
	// we can prevent connections to ourselves.
	sentNonces lru.Cache

	// This section defines the data structures for storing all the
	// peers we're aware of.
	//
	// A count of the number active connections we have for each IP group.
	// We use this to ensure we don't connect to more than one outbound
	// peer from the same IP group. We need a mutex on it because it's used
	// concurrently by many goroutines to figure out if outbound connections
	// should be made to particular addresses.

	mtxOutboundConnIPGroups deadlock.Mutex
	outboundConnIPGroups    map[string]int
	// The peer maps map peer ID to peers for various types of peer connections.
	//
	// A persistent peer is typically one we got through a commandline argument.
	// The reason it's called persistent is because we maintain a connection to
	// it, and retry the connection if it fails.
	mtxPeerMaps     deadlock.RWMutex
	persistentPeers map[uint64]*Peer
	outboundPeers   map[uint64]*Peer
	inboundPeers    map[uint64]*Peer
	// Track the number of outbound peers we have so that this value can
	// be accessed concurrently when deciding whether or not to add more
	// outbound peers.
	numOutboundPeers   uint32
	numInboundPeers    uint32
	numPersistentPeers uint32

	// We keep track of the addresses for the outbound peers so that we can
	// avoid choosing them in the address manager. We need a mutex on this
	// guy because many goroutines will be querying the address manager
	// at once.
	mtxConnectedOutboundAddrs deadlock.RWMutex
	connectedOutboundAddrs    map[string]bool

	// Used to set peer ids. Must be incremented atomically.
	peerIndex uint64

	serverMessageQueue chan *ServerMessage

	// Keeps track of the network time, which is the median of all of our
	// peers' time.
	timeSource chainlib.MedianTimeSource

	// Events that can happen to a peer.
	newPeerChan  chan *Peer
	donePeerChan chan *Peer

	// stallTimeoutSeconds is how long we wait to receive responses from Peers
	// for certain types of messages.
	stallTimeoutSeconds uint64

	minFeeRateNanosPerKB uint64

	// More chans we might want.	modifyRebroadcastInv chan interface{}
	shutdown int32
} 
type DeSoBlockProducer struct {
	// The minimum amount of time we wait before trying to produce a new block
	// template. If this value is set low enough then we will produce a block template
	// continuously.
	minBlockUpdateIntervalSeconds uint64
	// The number of templates to cache so that we can accept headers for blocks
	// that are a bit stale.
	maxBlockTemplatesToCache uint64
	// A private key that is used to sign blocks produced by this block producer. Only
	// set if a blockProducerSeed is provided when constructing the BlockProducer.
	blockProducerPrivateKey *btcec.PrivateKey
	// A lock on the block templates produced to avoid concurrency issues.
	mtxRecentBlockTemplatesProduced deadlock.RWMutex
	// The most recent N blocks that we've produced indexed by their hash.
	// Keeping this list allows us to accept a valid header from a miner without
	// requiring them to download/send the whole block.
	recentBlockTemplatesProduced map[BlockHash]*MsgDeSoBlock
	latestBlockTemplateHash      *BlockHash
	currentDifficultyTarget      *BlockHash

	latestBlockTemplateStats *BlockTemplateStats

	mempool *DeSoMempool
	chain   *Blockchain
	params  *DeSoParams

	producerWaitGroup   sync.WaitGroup
	stopProducerChannel chan struct{}

	postgres *Postgres
} 
type BlockTemplateStats struct {
	// The number of txns in the block template.
	TxnCount uint32
	// The final txn we attempted to put in the block.
	FailingTxnHash string
	// The reason why the final txn failed to add.
	FailingTxnError string
	// The "Added" time on a transaction changes every time a block is mined so we record
	// the first time added val we are aware of for a specific txn hash here.
	FailingTxnOriginalTimeAdded time.Time
	// The time since the failing txn was added to the mempool.
	FailingTxnMinutesSinceAdded float64
} 
type DeSoMessage interface {
	// The following methods allow one to convert a message struct into
	// a byte slice and back. Example usage:
	//
	//   params := &DeSoTestnetParams
	//   msgType := MsgTypeVersion
	//   byteSlice := []byte{0x00, ...}
	//
	// 	 msg := NewMessage(msgType)
	//   err := msg.FromBytes(byteSlice)
	//   newByteSlice, err := msg.ToBytes(false)
	//
	// The data format is intended to be compact while allowing for efficient
	// transmission over the wire and storage in a database.
	//
	// The preSignature field specifies whether the message should be fully
	// serialized or whether it should be serialized in such a way that it
	// can be signed (which involves, for example, not serializing signature
	// fields).
	ToBytes(preSignature bool) ([]byte, error)
	FromBytes(data []byte) error

	// Each Message has a particular type.
	GetMsgType() MsgType
} 
type DeSoTxnMetadata interface {
	ToBytes(preSignature bool) ([]byte, error)
	FromBytes(data []byte) error
	New() DeSoTxnMetadata
	GetTxnType() TxnType
} 
type MsgDeSoQuit struct {
} 
type MsgDeSoNewPeer struct {
} 
type MsgDeSoDonePeer struct {
} 
type MsgDeSoBitcoinManagerUpdate struct {
	// Keep it simple for now. A BitcoinManagerUpdate just signals that
	// the BitcoinManager has added at least one block or done a reorg.
	// No serialization because we don't want this sent on the wire ever.
	TransactionsFound []*MsgDeSoTxn
} 
type MsgDeSoGetHeaders struct {
	StopHash     *BlockHash
	BlockLocator []*BlockHash
} 
type MsgDeSoHeaderBundle struct {
	Headers   []*MsgDeSoHeader
	TipHash   *BlockHash
	TipHeight uint32
} 
type MsgDeSoGetBlocks struct {
	HashList []*BlockHash
} 
type DeSoBodySchema struct {
	Body      string   `json:",omitempty"`
	ImageURLs []string `json:",omitempty"`
	VideoURLs []string `json:",omitempty"`
} 
type MsgDeSoGetTransactions struct {
	HashList []*BlockHash
} 
type MsgDeSoTransactionBundle struct {
	Transactions []*MsgDeSoTxn
} 
type MsgDeSoMempool struct {
} 
type InvVect struct {
	Type InvType   // Type of data
	Hash BlockHash // Hash of the data
} 
type MsgDeSoInv struct {
	InvList []*InvVect
	// IsSyncResponse indicates that the inv was sent in response to a sync message.
	// This indicates that the node shouldn't relay it to peers because they likely
	// already have it.
	IsSyncResponse bool
} 
type MsgDeSoPing struct {
	Nonce uint64
} 
type MsgDeSoPong struct {
	Nonce uint64
} 
type MsgDeSoVersion struct {
	// What is the current version we're on?
	Version uint64

	// What are the services offered by this node?
	Services ServiceFlag

	// The node's unix timestamp that we use to compute a
	// robust "network time" using NTP.
	TstampSecs int64

	// Used to detect when a node connects to itself, which
	// we generally want to prevent.
	Nonce uint64

	// Used as a "vanity plate" to identify different DeSo
	// clients. Mainly useful in analyzing the network at
	// a meta level, not in the protocol itself.
	UserAgent string

	// The height of the last block on the main chain for
	// this node.
	//
	// TODO: We need to update this to uint64
	StartBlockHeight uint32

	// MinFeeRateNanosPerKB is the minimum feerate that a peer will
	// accept from other peers when validating transactions.
	MinFeeRateNanosPerKB uint64
} 
type SingleAddr struct {
	// Last time the address was seen. Encoded as number UNIX seconds on the wire.
	Timestamp time.Time

	// Bitfield which identifies the services supported by the address.
	Services ServiceFlag

	// IP address of the peer. Must be 4 or 16 bytes for IPV4 or IPV6 respectively.
	IP net.IP

	// Port the peer is using.
	Port uint16
} 
type MsgDeSoAddr struct {
	// The definition of NetAddress as defined by the btcd guys works fine for
	// our purposes. The only difference is that for DeSo nodes, the Service
	// flag in the NetAddress is as we define it above in ServiceFlag.
	// Note that we also rewrite the serialization logic as well to avoid
	// relying on potentially crusty Bitcoin-related work-arounds going forward.
	AddrList []*SingleAddr
} 
type MsgDeSoGetAddr struct {
} 
type MsgDeSoVerack struct {
	// A verack message must contain the nonce the peer received in the
	// initial version message. This ensures the peer that is communicating
	// with us actually controls the address she says she does similar to
	// "SYN Cookie" DDOS protection.
	Nonce uint64
} 
type MsgDeSoHeader struct {
	// Note this is encoded as a fixed-width uint32 rather than a
	// uvarint or a uint64.
	Version uint32

	// Hash of the previous block in the chain.
	PrevBlockHash *BlockHash

	// The merkle root of all the transactions contained within the block.
	TransactionMerkleRoot *BlockHash

	// The unix timestamp (in seconds) specifying when this block was
	// mined.
	TstampSecs uint64

	// The height of the block this header corresponds to.
	Height uint64

	// The nonce that is used by miners in order to produce valid blocks.
	//
	// Note: Before the upgrade from HeaderVersion0 to HeaderVersion1, miners would make
	// use of ExtraData in the BlockRewardMetadata to get extra nonces. However, this is
	// no longer needed since HeaderVersion1 upgraded the nonce to 64 bits from 32 bits.
	Nonce uint64

	// An extra nonce that can be used to provice *even more* entropy for miners, in the
	// event that ASICs become powerful enough to have birthday problems in the future.
	ExtraNonce uint64
} 
type BlockProducerInfo struct {
	PublicKey []byte
	Signature *btcec.Signature
} 
type MsgDeSoBlock struct {
	Header *MsgDeSoHeader
	Txns   []*MsgDeSoTxn

	// This field is optional and provides the producer of the block the ability to sign it
	// with their private key. Doing this proves that this block was produced by a particular
	// entity, which can be useful for nodes that want to restrict who they accept blocks
	// from.
	BlockProducerInfo *BlockProducerInfo
} 
type UtxoKey struct {
	// The 32-byte transaction id where the unspent output occurs.
	TxID BlockHash
	// The index within the txn where the unspent output occurs.
	Index uint32
} 
type DeSoOutput struct {
	// Outputs always compensate a specific public key.
	PublicKey []byte
	// The amount of DeSo to send to this public key.
	AmountNanos uint64
} 
type MsgDeSoTxn struct {
	TxInputs  []*DeSoInput
	TxOutputs []*DeSoOutput

	// DeSoTxnMetadata is an interface type that will give us information on how
	// we should handle the transaction, including what type of transaction this
	// is.
	TxnMeta DeSoTxnMetadata

	// Transactions must generally explicitly include the key that is
	// spending the inputs to the transaction. The exception to this rule is that
	// BlockReward and BitcoinExchange transactions do not require the inclusion
	// of a public key since they have no inputs to spend.
	//
	// The public key should be a serialized compressed ECDSA public key on the
	// secp256k1 curve.
	PublicKey []byte

	// This is typically a JSON field that can be used to add extra information to
	// a transaction without causing a hard fork. It is useful in rare cases where we
	// realize that something needs to be added to a transaction but where we can't
	// afford a hard fork.
	ExtraData map[string][]byte

	// Transactions must generally be signed by the key that is spending the
	// inputs to the transaction. The exception to this rule is that
	// BLOCK_REWARD and CREATE_deso transactions do not require a signature
	// since they have no inputs.
	Signature *btcec.Signature

	// (!!) **DO_NOT_USE** (!!)
	//
	// Use txn.TxnMeta.GetTxnType() instead.
	//
	// We need this for JSON encoding/decoding. It isn't used for anything
	// else and it isn't actually serialized or de-serialized when sent
	// across the network using ToBytes/FromBytes because we prefer that
	// any use of the MsgDeSoTxn in Go code rely on TxnMeta.GetTxnType() rather
	// than checking this value, which, in Go context, is redundant and
	// therefore error-prone (e.g. someone might change TxnMeta while
	// forgetting to set it). We make it a uint64 explicitly to prevent
	// people from using it in Go code.
	TxnTypeJSON uint64
} 
type BasicTransferMetadata struct {
	// Requires no extra information
} 
type BlockRewardMetadataa struct {
	// A block reward txn has an ExtraData field that can be between
	// zero and 100 bytes long. It can theoretically contain anything
	// but in practice it's likely that miners will use this field to
	// update the merkle root of the block, which may make the block
	// easier to mine (namely by allowing the Nonce in the header to
	// be shorter).
	ExtraData []byte
} 
type BitcoinExchangeMetadata struct {
	// The Bitcoin transaction that sends Bitcoin to the designated burn address.
	BitcoinTransaction *wire.MsgTx
	// The hash of the Bitcoin block in which the Bitcoin transaction was mined.
	BitcoinBlockHash *BlockHash
	// The Bitcoin mekle root corresponding to the block in which the BitcoinTransaction
	// above was mined. Note that it is not strictly necessary to include this field
	// since we can look it up from the Bitcoin header if we know the BitcoinBlockHash.
	// However, having it here is convenient and allows us to do more validation prior
	// to looking up the header in the Bitcoin header chain.
	BitcoinMerkleRoot *BlockHash
	// This is a merkle proof that shows that the BitcoinTransaction above, with
	// hash equal to BitcoinTransactionHash, exists in the block with hash equal
	// to BitcoinBlockHash. This is effectively a path through a Merkle tree starting
	// from BitcoinTransactionHash as a leaf node and finishing with BitcoinMerkleRoot
	// as the root.
	BitcoinMerkleProof []*merkletree.ProofPart
} 
type PrivateMessageMetadata struct {
	// The sender of the message is assumed to be the originator of the
	// top-level transaction.

	// The public key of the recipient of the message.
	RecipientPublicKey []byte

	// The content of the message. It is encrypted with the recipient's
	// public key using ECIES.
	EncryptedText []byte

	// A timestamp used for ordering messages when displaying them to
	// users. The timestamp must be unique. Note that we use a nanosecond
	// timestamp because it makes it easier to deal with the uniqueness
	// constraint technically (e.g. If one second spacing is required
	// as would be the case with a standard Unix timestamp then any code
	// that generates these transactions will need to potentially wait
	// or else risk a timestamp collision. This complexity is avoided
	// by just using a nanosecond timestamp). Note that the timestamp is
	// an unsigned int as opposed to a signed int, which means times
	// before the zero time are not represented which doesn't matter
	// for our purposes. Restricting the timestamp in this way makes
	// lexicographic sorting based on bytes easier in our database which
	// is one of the reasons we do it.
	TimestampNanos uint64
} 
type LikeMetadata struct {
	// The user casting a "like" is assumed to be the originator of the
	// top-level transaction.

	// The post hash to like.
	LikedPostHash *BlockHash

	// Set to true when a user is requesting to unlike a post.
	IsUnlike bool
} 
type FollowMetadata struct {
	// The follower is assumed to be the originator of the
	// top-level transaction.

	// The public key to follow.
	FollowedPublicKey []byte

	// Set to true when a user is requesting to unfollow.
	IsUnfollow bool
} 
type SubmitPostMetadata struct {
	// The creator of the post is assumed to be the originator of the
	// top-level transaction.

	// When set, this transaction is treated as modifying an existing
	// post rather than creating a new post.
	PostHashToModify []byte

	// When a ParentStakeID is set, the post is actually a comment on
	// another entity (either a post or a profile depending on the
	// type of StakeID provided).
	ParentStakeID []byte
	Body          []byte

	// The amount the creator of the post gets when someone stakes
	// to the post.
	CreatorBasisPoints uint64
	// The multiple of the payout when a user stakes to a post.
	// 2x multiple = 200% = 20,000bps
	StakeMultipleBasisPoints uint64

	// A timestamp used for ordering messages when displaying them to
	// users. The timestamp must be unique. Note that we use a nanosecond
	// timestamp because it makes it easier to deal with the uniqueness
	// constraint technically (e.g. If one second spacing is required
	// as would be the case with a standard Unix timestamp then any code
	// that generates these transactions will need to potentially wait
	// or else risk a timestamp collision. This complexity is avoided
	// by just using a nanosecond timestamp). Note that the timestamp is
	// an unsigned int as opposed to a signed int, which means times
	// before the zero time are not represented which doesn't matter
	// for our purposes. Restricting the timestamp in this way makes
	// lexicographic sorting based on bytes easier in our database which
	// is one of the reasons we do it.
	TimestampNanos uint64

	// When set to true, indicates that the post should be deleted. This
	// value is only considered when PostHashToModify is set to a valid
	// pre-existing post.
	IsHidden bool
} 
type UpdateProfileMetadata struct {
	// The public key being updated is assumed to be the originator of the
	// top-level transaction.

	// The public key of the profile to update. When left unset, the public
	// key in the transaction is used.
	ProfilePublicKey []byte

	NewUsername    []byte
	NewDescription []byte
	NewProfilePic  []byte

	// This is the percentage of each "net buy" that a creator earns when
	// someone purchases her coin. For example, if this were set to 25%,
	// then every time their coin reaches a new high, they would get 25%
	// of the coins as they're being minted. More concretely, if someone
	// put in enough DeSo to buy 10 coins, the creator would get 2.5
	// and this person would get 7.5. However, if they sold 5 coins and
	// someone subsequently bought those same coins, the creator wouldn't
	// get any coins because no "net new" coins have been created.
	NewCreatorBasisPoints uint64

	// The multiple of the payout when a user stakes to this profile. If
	// unset, a sane default is set when the first person stakes to this
	// profile.
	// 2x multiple = 200% = 20,000bps
	//
	// TODO: This field is deprecated; delete it.
	NewStakeMultipleBasisPoints uint64

	// Profile is hidden from the UI when this field is true.
	// TODO: This field is deprecated; delete it.
	IsHidden bool
} 
type UpdateGlobalParamsMetadata struct {
	// The GlobalParamsMetadata struct is empty because all information is stored in the transaction's ExtraData
} 
type UpdateBitcoinUSDExchangeRateMetadataa struct {
	// The new exchange rate to set.
	USDCentsPerBitcoin uint64
} 
type CreatorCoinMetadataa struct {
	// ProfilePublicKey is the public key of the profile that owns the
	// coin the person wants to operate on. Creator coins can only be
	// bought and sold if a valid profile exists.
	ProfilePublicKey []byte

	// OperationType specifies what the user wants to do with this
	// creator coin.
	OperationType CreatorCoinOperationType

	// Generally, only one of these will be used depending on the OperationType
	// set. In a Buy transaction, DeSoToSellNanos will be converted into
	// creator coin on behalf of the user. In a Sell transaction,
	// CreatorCoinToSellNanos will be converted into DeSo. In an AddDeSo
	// operation, DeSoToAddNanos will be aded for the user. This allows us to
	// support multiple transaction types with same meta field.
	DeSoToSellNanos        uint64
	CreatorCoinToSellNanos uint64
	DeSoToAddNanos         uint64

	// When a user converts DeSo into CreatorCoin, MinCreatorCoinExpectedNanos
	// specifies the minimum amount of creator coin that the user expects from their
	// transaction. And vice versa when a user is converting CreatorCoin for DeSo.
	// Specifying these fields prevents the front-running of users' buy/sell. Setting
	// them to zero turns off the check. Give it your best shot, Ivan.
	MinDeSoExpectedNanos        uint64
	MinCreatorCoinExpectedNanos uint64
} 
type CreatorCoinTransferMetadataa struct {
	// ProfilePublicKey is the public key of the profile that owns the
	// coin the person wants to transer. Creator coins can only be
	// transferred if a valid profile exists.
	ProfilePublicKey []byte

	CreatorCoinToTransferNanos uint64
	ReceiverPublicKey          []byte
} 
type CreateNFTMetadata struct {
	NFTPostHash                    *BlockHash
	NumCopies                      uint64
	HasUnlockable                  bool
	IsForSale                      bool
	MinBidAmountNanos              uint64
	NFTRoyaltyToCreatorBasisPoints uint64
	NFTRoyaltyToCoinBasisPoints    uint64
} 
type UpdateNFTMetadata struct {
	NFTPostHash       *BlockHash
	SerialNumber      uint64
	IsForSale         bool
	MinBidAmountNanos uint64
} 
type AcceptNFTBidMetadata struct {
	NFTPostHash    *BlockHash
	SerialNumber   uint64
	BidderPKID     *PKID
	BidAmountNanos uint64
	UnlockableText []byte

	// When an NFT owner accepts a bid, they must specify the bidder's UTXO inputs they will lock up
	// as payment for the purchase. This prevents the transaction from accidentally using UTXOs
	// that are used by future transactions.
	BidderInputs []*DeSoInput
} 
type NFTBidMetadata struct {
	NFTPostHash    *BlockHash
	SerialNumber   uint64
	BidAmountNanos uint64
} 
type NFTTransferMetadata struct {
	NFTPostHash       *BlockHash
	SerialNumber      uint64
	ReceiverPublicKey []byte
	UnlockableText    []byte
} 
type AcceptNFTTransferMetadata struct {
	NFTPostHash  *BlockHash
	SerialNumber uint64
} 
type BurnNFTMetadata struct {
	NFTPostHash  *BlockHash
	SerialNumber uint64
} 

type SwapIdentityMetadataa struct {
	// TODO: This is currently only accessible by ParamUpdater. This avoids the
	// possibility that a user will stomp over another user's profile, and
	// simplifies the logic. In the long run, though, we should eliminate all
	// dependencies on ParamUpdater.

	// The public key that we are swapping *from*. Doesn't matter which public
	// key is *from* and which public key is *to* because it's just a swap.
	FromPublicKey []byte

	// The public key that we are swapping *to*. Doesn't matter which public
	// key is *from* and which public key is *to* because it's just a swap.
	ToPublicKey []byte
} 
type AuthorizeDerivedKeyMetadata struct {
	// DerivedPublicKey is the key that is authorized to sign transactions
	// on behalf of the public key owner.
	DerivedPublicKey []byte

	// ExpirationBlock is the block at which this authorization becomes invalid.
	ExpirationBlock uint64

	// OperationType determines if transaction validates or invalidates derived key.
	OperationType AuthorizeDerivedKeyOperationType

	// AccessSignature is the signed hash of (derivedPublicKey + expirationBlock)
	// made with the ownerPublicKey. Signature is in the DER format.
	AccessSignature []byte
} 
type DAOCoinMetadata struct {
	// ProfilePublicKey is the public key of the profile that owns the
	// coin the person wants to operate on.
	ProfilePublicKey []byte

	// OperationType specifies what the user wants to do with this
	// DAO coin.
	OperationType DAOCoinOperationType

	// TODO: Should we only have one field that tracks number of coins in operation to keep this struct small?
	// We will only ever need 1 of these fields.
	// Mint field
	CoinsToMintNanos uint256.Int

	// Burn Fields
	CoinsToBurnNanos uint256.Int

	// TransferRestrictionStatus to set if OperationType == DAOCoinOperatoinTypeUpdateTransferRestrictionStatus
	TransferRestrictionStatus
} 
type DAOCoinTransferMetadata struct {
	// ProfilePublicKey is the public key of the profile that owns the
	// coin the person wants to transfer. DAO coins can only be
	// transferred if a valid profile exists.
	ProfilePublicKey []byte

	DAOCoinToTransferNanos uint256.Int
	ReceiverPublicKey      []byte
} 
type MessagingGroupMetadata struct {
	// This struct is very similar to the MessagingGroupEntry type.
	MessagingPublicKey    []byte
	MessagingGroupKeyName []byte
	// This value is the signature of the following using the private key
	// of the GroupOwnerPublicKey (aka txn.PublicKey):
	// - Sha256DoubleHash(MessagingPublicKey || MessagingGroupKeyName)
	//
	// This signature is only required when setting up a group where
	// - MessagingGroupKeyName = "default-key"
	// In this case, we want to make sure that people don't accidentally register
	// this group name with a derived key, and forcing this signature ensures that.
	// The reason is that if someone accidentally registers the default-key with
	// the wrong public key, then they won't be able to receive messages cross-device
	// anymore.
	//
	// This field is not critical and can be removed in the future.
	GroupOwnerSignature   []byte

	MessagingGroupMembers []*MessagingGroupMember
} 
type MsgType uint64
 
type TxnType uint8
 
type InvType uint32
 
type ServiceFlag uint64
 
type CreatorCoinOperationType uint8
 
type SwapIdentityOperationType uint8
 
type AuthorizeDerivedKeyOperationType uint8
 
type DAOCoinOperationType uint8
 
type TxnString string 
type DeSoInput UtxoKey
 
type DeSoMiner struct {
	PublicKeys    []*btcec.PublicKey
	numThreads    uint32
	BlockProducer *DeSoBlockProducer
	params        *DeSoParams

	stopping int32
} 
type DeSoNode struct {
	// Name of the node, displayed to users
	Name string

	// HTTPs URL to the node or app
	URL string

	// DeSo username of the node owner
	Owner string
} 
type ETHTx struct {
	Nonce   string `json:"nonce"`
	Value   string `json:"value"`
	ChainId string `json:"chainId"`
	To      string `json:"to"`
	R       string `json:"r"`
	S       string `json:"s"`
} 
type SubmitETHTxRequest struct {
	PublicKeyBase58Check string
	Tx                   ETHTx
	TxBytes              string
	ToSign               []string
	SignedHashes         []string
} 
type SubmitETHTxResponse struct {
	DESOTxHash string
} 
type ETHTxLog struct {
	PublicKey  []byte
	DESOTxHash string
} 
type AdminProcessETHTxRequest struct {
	ETHTxHash string
} 
type AdminProcessETHTxResponse struct {
	DESOTxHash string
} 
type InfuraRequest struct {
	JSONRPC string        `json:"jsonrpc"`
	Method  string        `json:"method"`
	Params  []interface{} `json:"params"`
	Id      uint64        `json:"id"`
} 
type InfuraResponse struct {
	Id      uint64      `json:"id"`
	JSONRPC string      `json:"jsonrpc"`
	Result  interface{} `json:"result"`
	Error   struct {
		Code    float64 `json:"code"`
		Message string  `json:"message"`
	} `json:"error"`
} 
type InfuraTx struct {
	BlockHash        *string `json:"blockHash"`
	BlockNumber      *string `json:"blockNumber"`
	From             string  `json:"from"`
	Gas              string  `json:"gas"`
	GasPrice         string  `json:"gasPrice"`
	Hash             string  `json:"hash"`
	Input            string  `json:"input"`
	Nonce            string  `json:"nonce"`
	To               *string `json:"to"`
	TransactionIndex *string `json:"transactionIndex"`
	Value            string  `json:"value"`
	V                string  `json:"v"`
	R                string  `json:"r"`
	S                string  `json:"s"`
} 
type QueryETHRPCRequest struct {
	Method               string
	Params               []interface{}
} 
type ExpectedResponse struct {
	TimeExpected time.Time
	MessageType  MsgType
} 
type DeSoMessageMeta struct {
	DeSoMessage DeSoMessage
	Inbound     bool
} 
type Peer struct {
	// These stats should be accessed atomically.
	bytesReceived uint64
	bytesSent     uint64
	totalMessages uint64
	lastRecv      int64
	lastSend      int64

	// Stats that should be accessed using the mutex below.
	StatsMtx       deadlock.RWMutex
	timeOffsetSecs int64
	timeConnected  time.Time
	startingHeight uint32
	ID             uint64
	// Ping-related fields.
	LastPingNonce  uint64
	LastPingTime   time.Time
	LastPingMicros int64

	// Connection info.
	cmgr                *ConnectionManager
	conn                net.Conn
	isOutbound          bool
	isPersistent        bool
	stallTimeoutSeconds uint64
	Params              *DeSoParams
	MessageChan         chan *ServerMessage
	// A hack to make it so that we can allow an API endpoint to manually
	// delete a peer.
	PeerManuallyRemovedFromConnectionManager bool

	// In order to complete a version negotiation successfully, the peer must
	// reply to the initial version message we send them with a verack message
	// containing the nonce from that initial version message. This ensures that
	// the peer's IP isn't being spoofed since the only way to actually produce
	// a verack with the appropriate response is to actually own the IP that
	// the peer claims it has. As such, we maintain the version nonce we sent
	// the peer and the version nonce they sent us here.
	//
	// TODO: The way we synchronize the version nonce is currently a bit
	// messy; ideally we could do it without keeping global state.
	versionNonceSent     uint64
	versionNonceReceived uint64

	// A pointer to the Server
	srv *Server

	// Basic state.
	PeerInfoMtx               deadlock.Mutex
	serviceFlags              ServiceFlag
	addrStr                   string
	netAddr                   *wire.NetAddress
	userAgent                 string
	advertisedProtocolVersion uint64
	negotiatedProtocolVersion uint64
	versionNegotiated         bool
	minTxFeeRateNanosPerKB    uint64
	// Messages for which we are expecting a reply within a fixed
	// amount of time. This list is always sorted by ExpectedTime,
	// with the item having the earliest time at the front.
	expectedResponses []*ExpectedResponse

	// The addresses this peer is aware of.
	knownAddressMapLock deadlock.RWMutex
	knownAddressesmap   map[string]bool

	// Output queue for messages that need to be sent to the peer.
	outputQueueChan chan DeSoMessage

	// Set to zero until Disconnect has been called on the Peer. Used to make it
	// so that the logic in Disconnect will only be executed once.
	disconnected int32
	// Signals that the peer is now in the stopped state.
	quit chan interface{}

	// Each Peer is only allowed to have certain number of blocks being sent
	// to them at any gven time. We use
	// this value to enforce that constraint. The reason we need to do this is without
	// it one peer could theoretically clog our Server by issuing many GetBlocks
	// requests that ultimately don't get delivered. This way the number of blocks
	// being sent is limited to a multiple of the number of Peers we have.
	blocksToSendMtx deadlock.Mutex
	blocksToSend    map[BlockHash]bool

	// Inventory stuff.
	// The inventory that we know the peer already has.
	knownInventory lru.Cache

	// Whether the peer is ready to receive INV messages. For a peer that
	// still needs a mempool download, this is false.
	canReceiveInvMessagess bool

	// We process GetTransaction requests in a separate loop. This allows us
	// to ensure that the responses are ordered.
	mtxMessageQueue deadlock.RWMutex
	messagQueue     []*DeSoMessageMeta

	requestedBlocks map[BlockHash]bool
} 
type ExtraDataDecoder func([]byte, DeSoParams) 
type ForkHeights struct {
	// Global Block Heights:
	// The block height at which various forks occurred including an
	// explanation as to why they're necessary.

	// The most deflationary event in DeSo history has yet to come...
	DeflationBombBlockHeight uint64

	// SalomonFixBlockHeight defines a block height where the protocol implements
	// two changes:
	// 	(1) The protocol now prints founder reward for all buy transactions instead
	//		of just when creators reach a new all time high.
	//		This was decided in order to provide lasting incentive for creators
	//		to utilize the protocol.
	//	(2) A fix was created to deal with a bug accidentally triggered by @salomon.
	//		After a series of buys and sells @salomon was left with a single creator coin
	//		nano in circulation and a single DeSo nano locked. This caused a detach
	//		between @salomon's bonding curve and others on the protocol. As more buys and sells
	//		continued, @salomon's bonding curve continued to detach further and further from its peers.
	// 		At its core, @salomon had too few creator coins in circulation. This fix introduces
	//		this missing supply back into circulation as well as prevented detached Bancor bonding
	//		curves from coming into existence.
	//		^ It was later decided to leave Salomon's coin circulation alone. A fix was introduced
	//		to prevent similar cases from occurring again, but @salomon is left alone.
	SalomonFixBlockHeight uint32

	// DeSoFounderRewardBlockHeight defines a block height where the protocol switches from
	// paying the founder reward in the founder's own creator coin to paying in DeSo instead.
	DeSoFounderRewardBlockHeight uint32

	// BuyCreatorCoinAfterDeletedBalanceEntryFixBlockHeight defines a block height after which the protocol will create
	// a new BalanceEntry when a user purchases a Creator Coin and their current BalanceEntry is deleted.
	// The situation in which a BalanceEntry reaches a deleted state occurs when a user transfers all their holdings
	// of a certain creator to another public key and subsequently purchases that same creator within the same block.
	// This resolves a bug in which users would purchase creator coins after transferring all holdings within the same
	// block and then the creator coins would be added to a deleted balance.  When the Balance Entries are flushed to
	// the database, the user would lose the creator coins they purchased.
	BuyCreatorCoinAfterDeletedBalanceEntryFixBlockHeight uint32

	// ParamUpdaterProfileUpdateFixBlockHeight defines a block height after which the protocol uses the update profile
	// txMeta's ProfilePublicKey when the Param Updater is creating a profile for ProfilePublicKey.
	ParamUpdaterProfileUpdateFixBlockHeight uint32

	// UpdateProfileFixBlockHeight defines the height at which a patch was added to prevent user from
	// updating the profile entry for arbitrary public keys that do not have existing profile entries.
	UpdateProfileFixBlockHeight uint32

	// BrokenNFTBidsFixBlockHeight defines the height at which the deso balance index takes effect
	// for accepting NFT bids.  This is used to fix a fork that was created by nodes running with a corrupted
	// deso balance index, allowing bids to be submitted that were greater than the user's deso balance.
	BrokenNFTBidsFixBlockHeight uint32

	// DeSoDiamondsBlockHeight defines the height at which diamonds will be given in DESO
	// rather than in creator coin.
	// Triggers: 3pm PT on 8/16/2021
	DeSoDiamondsBlockHeight uint32

	// NFTTransfersBlockHeight defines the height at which NFT transfer txns, accept NFT
	// transfer txns, NFT burn txns, and AuthorizeDerivedKey txns will be accepted.
	// Triggers: 12PM PT on 9/15/2021
	NFTTransferOrBurnAndDerivedKeysBlockHeight uint32

	// DeSoV3MessagesBlockHeight defines the height at which messaging key and messsage party
	// entries will be accepted by consensus.
	DeSoV3MessagesBlockHeight uint32

	// BuyNowAndNFTSplitsBlockHeight defines the height at which NFTs can be sold at a fixed price instead of an
	// auction style and allows splitting of NFT royalties to user's other than the post's creator.
	BuyNowAndNFTSplitsBlockHeight uint32

	// DAOCoinBlockHeight defines the height at which DAO Coin and DAO Coin Transfer
	// transactions will be accepted.
	DAOCoinBlockHeight uint32
} 
type DeSoParams struct {
	// The network type (mainnet, testnet, etc).
	NetworkType NetworkType
	// The current protocol version we're running.
	ProtocolVersion uint64
	// The minimum protocol version we'll allow a peer we connect to
	// to have.
	MinProtocolVersion uint64
	// Used as a "vanity plate" to identify different DeSo
	// clients. Mainly useful in analyzing the network at
	// a meta level, not in the protocol itself.
	UserAgent string
	// The list of DNS seed hosts to use during bootstrapping.
	DNSSeeds []string

	// A list of DNS seed prefixes and suffixes to use during bootstrapping.
	// These prefixes and suffixes will be scanned and all IPs found will be
	// incorporated into the address manager.
	DNSSeedGenerators [][]string

	// The network parameter for Bitcoin messages as defined by the btcd library.
	// Useful for certain function calls we make to this library.
	BitcoinBtcdParams *chaincfg.Params

	// Because we use the Bitcoin header chain only to process exchanges from
	// BTC to DeSo, we don't need to worry about Bitcoin blocks before a certain
	// point, which is specified by this node. This is basically used to make
	// header download more efficient but it's important to note that if for
	// some reason there becomes a different main chain that is stronger than
	// this one, then we will still switch to that one even with this parameter
	// set such as it is.
	BitcoinStartBlockNode *BlockNode

	// The base58Check-encoded Bitcoin address that users must send Bitcoin to in order
	// to purchase DeSo. Note that, unfortunately, simply using an all-zeros or
	// mostly-all-zeros address or public key doesn't work and, in fact, I found that
	// using almost any address other than this one also doesn't work.
	BitcoinBurnAddress string

	// This is a fee in basis points charged on BitcoinExchange transactions that gets
	// paid to the miners. Basically, if a user burned enough Satoshi to create 100 DeSo,
	// and if the BitcoinExchangeFeeBasisPoints was 1%, then 99 DeSo would be allocated to
	// the user's public key while 1 DeSo would be left as a transaction fee to the miner.
	BitcoinExchangeFeeBasisPoints uint64

	// The amount of time to wait for a Bitcoin txn to broadcast throughout the Bitcoin
	// network before checking for double-spends.
	BitcoinDoubleSpendWaitSeconds float64

	// This field allows us to set the amount purchased at genesis to a non-zero
	// value.
	DeSoNanosPurchasedAtGenesis uint64

	// Port used for network communications among full nodes.
	DefaultSocketPort uint16
	// Port used for the limited JSON API that supports light clients.
	DefaultJSONPort uint16

	// The amount of time we wait when connecting to a peer.
	DialTimeout time.Duration
	// The amount of time we wait to receive a version message from a peer.
	VersionNegotiationTimeout time.Duration

	// The genesis block to use as the base of our chain.
	GenesisBlock *MsgDeSoBlock
	// The expected hash of the genesis block. Should align with what one
	// would get from actually hashing the provided genesis block.
	GenesisBlockHashHex string
	// How often we target a single block to be generated.
	TimeBetweenBlocks time.Duration
	// How many blocks between difficulty retargets.
	TimeBetweenDifficultyRetargets time.Duration
	// Block hashes, when interpreted as big-endian big integers, must be
	// values less than or equal to the difficulty
	// target. The difficulty target is expressed below as a big-endian
	// big integer and is adjusted every TargetTimePerBlock
	// order to keep blocks generating at consistent intervals.
	MinDifficultyTargetHex string
	// We will reject chains that have less than this amount of total work,
	// expressed as a hexadecimal big-endian bigint. Useful for preventing
	// disk-fill attacks, among other things.
	MinChainWorkHex string

	// This is used for determining whether we are still in initial block download.
	// If our tip is older than this, we continue with IBD.
	MaxTipAge time.Duration

	// Do not allow the difficulty to change by more than a factor of this
	// variable during each adjustment period.
	MaxDifficultyRetargetFactor int64
	// Amount of time one must wait before a block reward can be spent.
	BlockRewardMaturity time.Duration
	// When shifting from v0 blocks to v1 blocks, we changed the hash function to
	// DeSoHash, which is technically easier. Thus we needed to apply an adjustment
	// factor in order to phase it in.
	V1DifficultyAdjustmentFactor int64

	// The maximum number of seconds in a future a block timestamp is allowed
	// to be before it is rejected.
	MaxTstampOffsetSeconds uint64

	// The maximum number of bytes that can be allocated to transactions in
	// a block.
	MaxBlockSizeBytes uint64

	// It's useful to set the miner maximum block size to a little lower than the
	// maximum block size in certain cases. For example, on initial launch, setting
	// it significantly lower is a good way to avoid getting hit by spam blocks.
	MinerMaxBlockSizeBytes uint64

	// In order to make public keys more human-readable, we convert
	// them to base58. When we do that, we use a prefix that makes
	// the public keys to become more identifiable. For example, all
	// mainnet public keys start with "X" because we do this.
	Base58PrefixPublicKey  [3]byte
	Base58PrefixPrivateKey [3]byte

	// MaxFetchBlocks is the maximum number of blocks that can be fetched from
	// a peer at one time.
	MaxFetchBlocks uint32

	MiningIterationsPerCycle uint64

	// deso
	MaxUsernameLengthBytes        uint64
	MaxUserDescriptionLengthBytes uint64
	MaxProfilePicLengthBytes      uint64
	MaxProfilePicDimensions       uint64
	MaxPrivateMessageLengthBytes  uint64

	StakeFeeBasisPoints         uint64
	MaxPostBodyLengthBytes      uint64
	MaxPostSubLengthBytes       uint64
	MaxStakeMultipleBasisPoints uint64
	MaxCreatorBasisPoints       uint64
	MaxNFTRoyaltyBasisPoints    uint64
	ParamUpdaterPublicKeys      map[PkMapKey]bool

	// A list of transactions to apply when initializing the chain. Useful in
	// cases where we want to hard fork or reboot the chain with specific
	// transactions applied.
	SeedTxns []string

	// A list of balances to initialize the blockchain with. This is useful for
	// testing and useful in the event that the devs need to hard fork the chain.
	SeedBalances []*DeSoOutput

	// This is a small fee charged on creator coin transactions. It helps
	// prevent issues related to floating point calculations.
	CreatorCoinTradeFeeBasisPoints uint64
	// These two params define the "curve" that we use when someone buys/sells
	// creator coins. Effectively, this curve amounts to a polynomial of the form:
	// - currentCreatorCoinPrice ~= slope * currentCreatorCoinSupply^(1/reserveRatio-1)
	// Buys and sells effectively take the integral of the curve in opposite directions.
	//
	// To better understand where this curve comes from and how it works, check out
	// the following links. They are all well written so don't be intimidated/afraid to
	// dig in and read them:
	// - Primer on bonding curves: https://medium.com/@simondlr/tokens-2-0-curved-token-bonding-in-curation-markets-1764a2e0bee5
	// - The Uniswap v2 white paper: https://whitepaper.io/document/600/uniswap-whitepaper
	// - The Bancor white paper: https://whitepaper.io/document/52/bancor-whitepaper
	// - Article relating Bancor curves to polynomial curves: https://medium.com/@aventus/token-bonding-curves-547f3a04914
	// - Derivations of the Bancor supply increase/decrease formulas: https://blog.relevant.community/bonding-curves-in-depth-intuition-parametrization-d3905a681e0a
	// - Implementations of Bancor equations in Solidity with code: https://yos.io/2018/11/10/bonding-curves/
	// - Bancor is flawed blog post discussing Bancor edge cases: https://hackingdistributed.com/2017/06/19/bancor-is-flawed/
	// - A mathematica equation sheet with tests that walks through all the
	//   equations. You will need to copy this into a Mathematica notebook to
	//   run it: https://pastebin.com/raw/M4a1femY
	CreatorCoinSlope        *big.Float
	CreatorCoinReserveRatio *big.Float

	// CreatorCoinAutoSellThresholdNanos defines two things. The first is the minimum amount
	// of creator coins a user must purchase in order for a transaction to be valid. Secondly
	// it defines the point at which a sell operation will auto liquidate all remaining holdings.
	// For example if I hold 1000 nanos of creator coins and sell x nanos such that
	// 1000 - x < CreatorCoinAutoSellThresholdNanos, we auto liquidate the remaining holdings.
	// It does this to prevent issues with floating point rounding that can arise.
	// This value should be chosen such that the chain is resistant to "phantom nanos." Phantom nanos
	// are tiny amounts of CreatorCoinsInCirculation/DeSoLocked which can cause
	// the effective reserve ratio to deviate from the expected reserve ratio of the bancor curve.
	// A higher CreatorCoinAutoSellThresholdNanos makes it prohibitively expensive for someone to
	// attack the bancor curve to any meaningful measure.
	CreatorCoinAutoSellThresholdNanos uint64

	ForkHeights ForkHeights
} 
type NetworkType uint64
 
type GetBlockTemplateRequest struct {
	PublicKeyBase58Check string

	// The number of headers the miner wants to receive. Each header will have a
	// random ExtraData associated with it, which gives it a unique MerkleRoot.
	// This ensures that different miners don't accidentally run through the same
	// search space.
	NumHeaders int64

	// Defaults to zero, which allows it to remain backwards-compatible with miners
	// that use an older version. Setting version=1 allows miners to hash using 128-bit
	// nonces, which may be advantageous.
	HeaderVersion uint32
} 
type GetBlockTemplateResponse struct {
	Headers [][]byte

	// Each header returned has an ExtraData associated with it that was embedded
	// in the block reward and which must be returned when SubmitBlock is called.
	//
	// TODO: This field should really be renamed ExtraDatas in JSON, but doing so
	// would break miners that are still running with v0 headers, so we will wait
	// to change this until v0 headers are fully deprecated.
	ExtraDatas []uint64 `json:"ExtraNonces"`

	// An identifier that the node uses to map a call to SubmitBlock back to the
	// block that was used to generate the headers.
	BlockID string

	// The difficulty target expressed in hex
	DifficultyTargetHex string

	// These fields provide metadata for the admin tab.
	LatestBlockTemplateStats BlockTemplateStats

	// TODO: The pool should return a merkle root that proves that the caller's
	// public key was the one that was included in the BlockRewardMetadata. This
	// isn't hard to do, and it would make this whole thing trustless, which would
	// be amazing.
} 
type SubmitBlockRequest struct {
	PublicKeyBase58Check string

	Header []byte

	// TODO: This field should be renamed ExtraData in JSON, but doing so would break
	// existing miners so we should make this update after we switch away from v0.
	ExtraData uint64 `json:"ExtraNonce"`

	BlockID string
} 
type SubmitBlockResponse struct {
	IsMainChain bool
	IsOrphan    bool
} 
type GetExchangeRateResponse struct {
	// BTC
	SatoshisPerDeSoExchangeRate    uint64
	USDCentsPerBitcoinExchangeRate uint64

	// ETH
	NanosPerETHExchangeRate    uint64
	USDCentsPerETHExchangeRate uint64

	// DESO
	NanosSold                          uint64
	USDCentsPerDeSoExchangeRate        uint64
	USDCentsPerDeSoReserveExchangeRate uint64
	BuyDeSoFeeBasisPoints              uint64

	SatoshisPerBitCloutExchangeRate        uint64 // Deprecated
	USDCentsPerBitCloutExchangeRate        uint64 // Deprecated
	USDCentsPerBitCloutReserveExchangeRate uint64 // Deprecated
} 
type BlockchainDeSoTickerResponse struct {
	Symbol         string  `json:"symbol"`
	Price24H       float64 `json:"price_24h"`
	Volume24H      float64 `json:"volume_24h"`
	LastTradePrice float64 `json:"last_trade_price"`
} 
type CoinbaseDeSoTickerResponse struct {
	Data struct {
		Base     string `json:"base"`
		Currency string `json:"currency"`
		Amount   string `json:"amount"` // In USD
	} `json:"data"`
} 
type GetAppStateRequest struct {
	PublicKeyBase58Check string
} 
type GetAppStateResponse struct {
	MinSatoshisBurnedForProfileCreation uint64
	BlockHeight                         uint32
	IsTestnet                           bool

	HasStarterDeSoSeed    bool
	HasTwilioAPIKey       bool
	CreateProfileFeeNanos uint64
	CompProfileCreation   bool
	DiamondLevelMap       map[int64]uint64
	HasWyreIntegration    bool
	HasJumioIntegration   bool
	BuyWithETH            bool

	USDCentsPerDeSoExchangeRate uint64
	JumioDeSoNanos              uint64 // Deprecated
	JumioUSDCents               uint64
	JumioKickbackUSDCents       uint64
	// CountrySignUpBonus is the sign-up bonus configuration for the country inferred from a request's IP address.
	CountrySignUpBonus CountryLevelSignUpBonus

	DefaultFeeRateNanosPerKB uint64
	TransactionFeeMap        map[string][]TransactionFee

	// Address to which we want to send ETH when used to buy DESO
	BuyETHAddress string

	Nodes map[uint64]lib.DeSoNode

	USDCentsPerBitCloutExchangeRate uint64 // Deprecated
	JumioBitCloutNanos              uint64 // Deprecated
} 
type GetGlobalParamsRequest struct {
} 
type GetGlobalParamsResponse struct {
	// The current exchange rate.
	USDCentsPerBitcoin uint64 `safeForLogging:"true"`

	// The current create profile fee
	CreateProfileFeeNanos uint64 `safeForLogging:"true"`

	// The current minimum fee the network will accept
	MinimumNetworkFeeNanosPerKB uint64 `safeForLogging:"true"`

	// The fee per copy of an NFT minted.
	CreateNFTFeeNanos uint64 `safeForLogging:"true"`

	// The maximum number of copies a single NFT can have.
	MaxCopiesPerNFT uint64 `safeForLogging:"true"`
} 
type UpdateGlobalParamsRequest struct {
	UpdaterPublicKeyBase58Check string `safeForLogging:"true"`
	// The new exchange rate to set.
	USDCentsPerBitcoin int64 `safeForLogging:"true"`

	// The fee to create a profile.
	CreateProfileFeeNanos int64 `safeForLogging:"true"`

	// The fee per copy of an NFT minted.
	CreateNFTFeeNanos int64 `safeForLogging:"true"`

	// The maximum number of copies a single NFT can have.
	MaxCopiesPerNFT int64 `safeForLogging:"true"`

	// The new minimum fee the network will accept
	MinimumNetworkFeeNanosPerKB int64 `safeForLogging:"true"`

	MinFeeRateNanosPerKB uint64 `safeForLogging:"true"`

	// No need to specify ProfileEntryResponse in each TransactionFee
	TransactionFees []TransactionFee `safeForLogging:"true"`

	// Can be left unset when Signature is false or if the user legitimately
	// doesn't have a password. Can also be left unset if the user has logged
	// in recently as the password will be stored in memory.
	Password string
	// Whether or not we should sign the transaction after constructing it.
	// Setting this flag to false is useful in
	// cases where the caller just wants to construct the transaction
	// to see what the fees will be, for example.
	Sign bool `safeForLogging:"true"`
	// Whether or not we should fully validate the transaction.
	Validate bool `safeForLogging:"true"`
	// Whether or not we should broadcast the transaction after constructing
	// it. This will also validate the transaction if it's set.
	Broadcast bool `safeForLogging:"true"`
} 
type UpdateGlobalParamsResponse struct {
	TotalInputNanos   uint64
	ChangeAmountNanos uint64
	FeeNanos          uint64
	Transaction       MsgDeSoTxn
	TransactionHex    string
} 
type SwapIdentityRequest struct {
	// This is currently paramUpdater only
	UpdaterPublicKeyBase58Check string `safeForLogging:"true"`

	// Either a username or a public key works. If it starts with BC and
	// is over the username limit it will be interpreted as a username.
	FromUsernameOrPublicKeyBase58Check string `safeForLogging:"true"`

	// Either a username or a public key works. If it starts with BC and
	//	// is over the username limit it will be interpreted as a username.
	ToUsernameOrPublicKeyBase58Check string `safeForLogging:"true"`

	MinFeeRateNanosPerKB uint64 `safeForLogging:"true"`

	// No need to specify ProfileEntryResponse in each TransactionFee
	TransactionFees []TransactionFee `safeForLogging:"true"`
} 
type SwapIdentityResponse struct {
	TotalInputNanos   uint64
	ChangeAmountNanos uint64
	FeeNanos          uint64
	Transaction       MsgDeSoTxn
	TransactionHex    string
} 
type TestSignTransactionWithDerivedKeyRequest struct {
	// Transaction hex.
	TransactionHex string `safeForLogging:"true"`

	// Derived private key in base58Check.
	DerivedKeySeedHex string `safeForLogging:"false"`
} 
type TestSignTransactionWithDerivedKeyResponse struct {
	// Signed Transaction hex.
	TransactionHex string `safeForLogging:"true"`
} 
type GetMessagesStatelessRequest struct {
	PublicKeyBase58Check string `safeForLogging:"true"`

	// FetchAfterPublicKeyBase58Check specifies where to start
	// in the messages to begin fetching new messages. If set empty,
	// we start fetching threads from the most recent message.
	FetchAfterPublicKeyBase58Check string `safeForLogging:"true"`

	// NumToFetch specifies the number of message threads to return. Defaults to 20
	// unless otherwise specified.
	NumToFetch uint64 `safeForLogging:"true"`

	// There are four filters: HoldersOnly, HoldingsOnly, FollowersOnly, FollowedOnly
	// If all filters are false, we return all messages. Otherwise we include
	// messages from the sets set true.

	// HoldersOnly when set true includes messages from holders.
	HoldersOnly bool `safeForLogging:"true"`

	// HoldingsOnly when set true includes messages from the user's holdings.
	HoldingsOnly bool `safeForLogging:"true"`

	// FollowersOnly when set true includes messages from the user's followers.
	FollowersOnly bool `safeForLogging:"true"`

	// FollowedOnly when set true includes messages from who the user follows.
	FollowingOnly bool `safeForLogging:"true"`

	// SortAlgorithm determines how the messages should be returned. Currently
	// it support time, deso, and followers based sorting.
	SortAlgorithm string `safeForLogging:"true"`
} 
type GetMessagesResponse struct {
	// PublicKeyToProfileEntry is a map of profile entries of the message parties. Keys are base58check public keys.
	PublicKeyToProfileEntry     map[string]*ProfileEntryResponse

	// OrderedContactsWithMessages is a list of message contacts. Each entry in the list corresponds to a messaging
	// thread and contains the public key and profile entry of the other party in the thread. Entries also contain a
	// list of encrypted messages for the threads.
	OrderedContactsWithMessages []*MessageContactResponse

	// UnreadStateByContact is a map indexed by public key base58check of contacts and with boolean values corresponding
	// to whether the thread has any unread messages. True means there are unread messages.
	UnreadStateByContact        map[string]bool

	// NumberOfUnreadThreads is a counter of how many unread threads are there.
	NumberOfUnreadThreads       int

	// MessagingGroups are all user's registered messaging keys and group chats that the user is a member of.
	MessagingGroups               []*MessagingGroupEntryResponse
} 
type SendMessageStatelessRequest struct {
	// SenderPublicKeyBase58Check is the public key in base58check of the message sender.
	SenderPublicKeyBase58Check     string `safeForLogging:"true"`

	// RecipientPublicKeyBase58Check is the public key in base58check of the messaging recipient.
	RecipientPublicKeyBase58Check  string `safeForLogging:"true"`

	MessageText                    string // Deprecated

	// EncryptedMessageText is the intended message content. It is recommended to pass actual encrypted message here,
	// although unencrypted message can be passed as well.
	EncryptedMessageText           string

	MinFeeRateNanosPerKB           uint64 `safeForLogging:"true"`
	// No need to specify ProfileEntryResponse in each TransactionFee
	TransactionFees                []TransactionFee `safeForLogging:"true"`

	// ---------------------------------------------------------
	// DeSo V3 Messages Fields
	// ---------------------------------------------------------

	// SenderMessagingGroupKeyName is the messaging group key name of the sender. If left empty, this endpoint
	// will replace it with the base messaging key. If both SenderMessagingGroupKeyName and
	// RecipientMessagingGroupKeyName are left empty, a V2 message will be constructed.
	SenderMessagingGroupKeyName    string `safeForLogging:"true"`

	// RecipientMessagingGroupKeyName is the messaging group key name of the recipient. If left empty, this endpoint
	// will replace it with the base messaging key. If both SenderMessagingGroupKeyName and
	// RecipientMessagingGroupKeyName are left empty, a V2 message will be constructed.
	RecipientMessagingGroupKeyName string `safeForLogging:"true"`
} 
type SendMessageStatelessResponse struct {
	TstampNanos uint64

	TotalInputNanos   uint64
	ChangeAmountNanos uint64
	FeeNanos          uint64
	Transaction       MsgDeSoTxn
	TransactionHex    string
} 
type MarkContactMessagesReadRequest struct {
	JWT                         string
	UserPublicKeyBase58Check    string
	ContactPublicKeyBase58Check string
} 
type MarkAllMessagesReadRequest struct {
	JWT                      string
	UserPublicKeyBase58Check string
} 
type RegisterMessagingGroupKeyRequest struct {
	// OwnerPublicKeyBase58Check is the public key in base58check of the account we want to register the messaging key for.
	OwnerPublicKeyBase58Check     string

	// MessagingPublicKeyBase58Check is the public key in base58check of the messaging group we want to register.
	MessagingPublicKeyBase58Check string

	// MessagingGroupKeyName is the name of the group key.
	MessagingGroupKeyName         string

	// MessagingKeySignatureHex is the signature of sha256x2(MessagingPublicKey + MessagingGroupKeyName). Currently,
	// the signature is only needed to register the default key.
	MessagingKeySignatureHex      string

	MinFeeRateNanosPerKB          uint64 `safeForLogging:"true"`

	// No need to specify ProfileEntryResponse in each TransactionFee
	TransactionFees []TransactionFee `safeForLogging:"true"`
} 
type RegisterMessagingGroupKeyResponse struct {
	TotalInputNanos   uint64
	ChangeAmountNanos uint64
	FeeNanos          uint64
	Transaction       MsgDeSoTxn
	TransactionHex    string
	TxnHashHex        string
} 
type GetAllMessagingGroupKeysRequest struct {
	// OwnerPublicKeyBase58Check is the public key in base58check of the account whose group messaging keys we want to fetch.
	OwnerPublicKeyBase58Check string
} 
type GetAllMessagingGroupKeysResponse struct {
	// MessagingGroupEntries is the list of all user's group messaging keys.
	MessagingGroupEntries []*MessagingGroupEntryResponse
} 
type CheckPartyMessagingKeysRequest struct {
	// SenderPublicKeyBase58Check is the main public key of the sender in base58check format.
	SenderPublicKeyBase58Check    string

	// SenderMessagingKeyName is the sender's key name the existence of which we want to verify.
	SenderMessagingKeyName        string

	// RecipientPublicKeyBase58Check is the public key of the recipient in base58check format.
	RecipientPublicKeyBase58Check string

	// RecipientMessagingKeyName is the recipient's key name the existence of we want to verify.
	RecipientMessagingKeyName     string
} 
type CheckPartyMessagingKeysResponse struct {
	// SenderMessagingPublicKeyBase58Check is the group messaging public key of the sender corresponding to the provided
	// SenderMessagingKeyName. This field will be an empty string if the key name doesn't exist.
	SenderMessagingPublicKeyBase58Check    string

	// SenderMessagingKeyName is the key name that was passed in the initial request. It's added to the response for
	// convenience.
	SenderMessagingKeyName                 string

	// IsSenderMessagingKey determines if the SenderMessagingKeyName existed for the sender.
	IsSenderMessagingKey                   bool

	// RecipientMessagingPublicKeyBase58Check is the group messaging public key of the recipient corresponding to the provided
	// RecipientMessagingKeyName. This field will be an empty string if the key name doesn't exist.
	RecipientMessagingPublicKeyBase58Check string

	// RecipientMessagingKeyName is the key name that was passed in the initial request. It's added to the response for
	// convenience.
	RecipientMessagingKeyName              string

	// IsRecipientMessagingKey determines if the RecipientMessagingKeyName existed for the sender.
	IsRecipientMessagingKey                bool
} 
type GetPostsStatelessRequest struct {
	// This is the PostHashHex of the post we want to start our paginated lookup at. We
	// will fetch up to "NumToFetch" posts after it, ordered by time stamp.  If no
	// PostHashHex is provided we will return the most recent posts.
	PostHashHex                string `safeForLogging:"true"`
	ReaderPublicKeyBase58Check string `safeForLogging:"true"`
	OrderBy                    string `safeForLogging:"true"`
	StartTstampSecs            uint64 `safeForLogging:"true"`
	PostContent                string `safeForLogging:"true"`
	NumToFetch                 int    `safeForLogging:"true"`

	// Note: if the GetPostsForFollowFeed option is passed, FetchSubcomments is currently ignored
	// (fetching comments / subcomments for the follow feed is currently unimplemented)
	FetchSubcomments bool `safeForLogging:"true"`

	// This gets posts by people that ReaderPublicKeyBase58Check follows.
	GetPostsForFollowFeed bool `safeForLogging:"true"`

	// This gets posts by people that ReaderPublicKeyBase58Check follows.
	GetPostsForGlobalWhitelist bool `safeForLogging:"true"`

	// This gets posts sorted by deso
	GetPostsByDESO  bool `safeForLogging:"true"`
	GetPostsByClout bool // Deprecated

	// This only gets posts that include media, like photos and videos
	MediaRequired bool `safeForLogging:"true"`

	PostsByDESOMinutesLookback uint64 `safeForLogging:"true"`

	// If set to true, then the posts in the response will contain a boolean about whether they're in the global feed
	AddGlobalFeedBool bool `safeForLogging:"true"`
} 
type PostEntryResponse struct {
	PostHashHex                string
	PosterPublicKeyBase58Check string
	ParentStakeID              string
	Body                       string
	ImageURLs                  []string
	VideoURLs                  []string
	RepostedPostEntryResponse  *PostEntryResponse
	CreatorBasisPoints         uint64
	StakeMultipleBasisPoints   uint64
	TimestampNanos             uint64
	IsHidden                   bool
	ConfirmationBlockHeight    uint32
	InMempool                  bool
	// The profile associated with this post.
	ProfileEntryResponse *ProfileEntryResponse
	// The comments associated with this post.
	Comments     []*PostEntryResponse
	LikeCount    uint64
	DiamondCount uint64
	// Information about the reader's state w/regard to this post (e.g. if they liked it).
	PostEntryReaderState PostEntryReaderState
	InGlobalFeed         *bool `json:",omitempty"`
	InHotFeed            *bool `json:",omitempty"`
	// True if this post hash hex is pinned to the global feed.
	IsPinned *bool `json:",omitempty"`
	// PostExtraData stores an arbitrary map of attributes of a PostEntry
	PostExtraData    map[string]string
	CommentCount     uint64
	RepostCount      uint64
	QuoteRepostCount uint64
	// A list of parent posts for this post (ordered: root -> closest parent post).
	ParentPosts []*PostEntryResponse

	// NFT info.
	IsNFT                          bool
	NumNFTCopies                   uint64
	NumNFTCopiesForSale            uint64
	NumNFTCopiesBurned             uint64
	HasUnlockable                  bool
	NFTRoyaltyToCreatorBasisPoints uint64
	NFTRoyaltyToCoinBasisPoints    uint64
	// This map specifies royalties that should go to user's  other than the creator
	AdditionalDESORoyaltiesMap map[string]uint64
	// This map specifies royalties that should be add to creator coins other than the creator's coin.
	AdditionalCoinRoyaltiesMap map[string]uint64

	// Number of diamonds the sender gave this post. Only set when getting diamond posts.
	DiamondsFromSender uint64

	// Score given to this post by the hot feed go routine. Not always populated.
	HotnessScore   uint64
	PostMultiplier float64

	RecloutCount               uint64             // Deprecated
	QuoteRecloutCount          uint64             // Deprecated
	RecloutedPostEntryResponse *PostEntryResponse // Deprecated
} 
type GetPostsStatelessResponse struct {
	PostsFound []*PostEntryResponse
} 
type GetSinglePostRequest struct {
	// PostHashHex to fetch.
	PostHashHex                string `safeForLogging:"true"`
	FetchParents               bool   `safeForLogging:"true"`
	CommentOffset              uint32 `safeForLogging:"true"`
	CommentLimit               uint32 `safeForLogging:"true"`
	ReaderPublicKeyBase58Check string `safeForLogging:"true"`
	// How many levels of replies will be retrieved. If unset, will only retrieve the top-level replies.
	ThreadLevelLimit           uint32 `safeForLogging:"true"`
	// How many child replies of a parent comment will be considered when returning a comment thread. Setting this to -1 will include all child replies. This limit does not affect the top-level replies to a post.
	ThreadLeafLimit int32 `safeForLogging:"true"`
	// If the post contains a comment thread where all comments are created by the author, include that thread in the response.
	LoadAuthorThread           bool   `safeForLogging:"true"`

	// If set to true, then the posts in the response will contain a boolean about whether they're in the global feed.
	AddGlobalFeedBool bool `safeForLogging:"true"`
} 
type GetSinglePostResponse struct {
	PostFound *PostEntryResponse
} 
type CommentsPostEntryResponse struct {
	PostEntryResponse *PostEntryResponse
	PosterPublicKeyBytes [] byte
} 

type GetPostsForPublicKeyRequest struct {
	// Either PublicKeyBase58Check or Username can be set by the client to specify
	// which user we're obtaining posts for
	// If both are specified, PublicKeyBase58Check will supercede
	PublicKeyBase58Check string `safeForLogging:"true"`
	Username             string `safeForLogging:"true"`

	ReaderPublicKeyBase58Check string `safeForLogging:"true"`
	// PostHashHex of the last post from the previous page
	LastPostHashHex string `safeForLogging:"true"`
	// Number of records to fetch
	NumToFetch    uint64 `safeForLogging:"true"`
	MediaRequired bool   `safeForLogging:"true"`
} 
type GetPostsForPublicKeyResponse struct {
	Posts           []*PostEntryResponse `safeForLogging:"true"`
	LastPostHashHex string               `safeForLogging:"true"`
} 
type GetPostsDiamondedBySenderForReceiverRequest struct {
	// Public key of the poster who received diamonds from the sender
	ReceiverPublicKeyBase58Check string

	// Username of Receiver
	ReceiverUsername string

	// Public key of the sender who gave diamonds to receiver
	SenderPublicKeyBase58Check string

	// Username of Sender
	SenderUsername string

	// Public key of the reader to get the post entry reader state
	ReaderPublicKeyBase58Check string

	// Start Post Hash Hex
	StartPostHashHex string

	// NumToFetch
	NumToFetch uint64
} 
type GetPostsDiamondedBySenderForReceiverResponse struct {
	// Map of diamond level to a list of post entry responses ordered by timestamp
	DiamondedPosts []*PostEntryResponse

	// Sum of all diamonds sender gave to receiver
	TotalDiamondsGiven uint64

	ReceiverProfileEntryResponse *ProfileEntryResponse

	SenderProfileEntryResponse *ProfileEntryResponse
} 
type GetLikesForPostRequest struct {
	// PostHashHex to fetch.
	PostHashHex                string `safeForLogging:"true"`
	Offset                     uint32 `safeForLogging:"true"`
	Limit                      uint32 `safeForLogging:"true"`
	ReaderPublicKeyBase58Check string `safeForLogging:"true"`
} 
type GetLikesForPostResponse struct {
	Likers []*ProfileEntryResponse
} 
type GetDiamondsForPostRequest struct {
	// PostHashHex to fetch.
	PostHashHex                string `safeForLogging:"true"`
	Offset                     uint32 `safeForLogging:"true"`
	Limit                      uint32 `safeForLogging:"true"`
	ReaderPublicKeyBase58Check string `safeForLogging:"true"`
} 
type GetDiamondsForPostResponse struct {
	DiamondSenders []*DiamondSenderResponse
} 
type DiamondSenderResponse struct {
	DiamondSenderProfile *ProfileEntryResponse
	DiamondLevel         int64
} 
type GetRepostsForPostRequest struct {
	// PostHashHex to fetch.
	PostHashHex                string `safeForLogging:"true"`
	Offset                     uint32 `safeForLogging:"true"`
	Limit                      uint32 `safeForLogging:"true"`
	ReaderPublicKeyBase58Check string `safeForLogging:"true"`
} 
type GetRepostsForPostResponse struct {
	Reposters  []*ProfileEntryResponse
	Reclouters []*ProfileEntryResponse // Deprecated
} 
type GetQuoteRepostsForPostRequest struct {
	// PostHashHex to fetch.
	PostHashHex                string `safeForLogging:"true"`
	Offset                     uint32 `safeForLogging:"true"`
	Limit                      uint32 `safeForLogging:"true"`
	ReaderPublicKeyBase58Check string `safeForLogging:"true"`
} 
type GetQuoteRepostsForPostResponse struct {
	QuoteReposts  []*PostEntryResponse
	QuoteReclouts []*PostEntryResponse // Deprecated
} 
type GetReferralInfoForUserRequest struct {
	PublicKeyBase58Check string `safeForLogging:"true"`

	JWT string
} 
type GetReferralInfoForUserResponse struct {
	ReferralInfoResponses []ReferralInfoResponse `safeForLogging:"true"`
} 
type GetReferralInfoForReferralHashRequest struct {
	ReferralHash string
} 
type GetReferralInfoForReferralHashResponse struct {
	ReferralInfoResponse *SimpleReferralInfoResponse
	CountrySignUpBonus   CountryLevelSignUpBonus
} 
type GetTutorialCreatorsRequest struct {
	ResponseLimit int
} 
type UpdateTutorialStatusRequest struct {
	PublicKeyBase58Check                string
	TutorialStatus                      TutorialStatus
	CreatorPurchasedInTutorialPublicKey string
	ClearCreatorCoinPurchasedInTutorial bool
	JWT                                 string
} 
type GetTutorialCreatorResponse struct {
	UpAndComingProfileEntryResponses []ProfileEntryResponse
	WellKnownProfileEntryResponses   []ProfileEntryResponse
} 
type StartOrSkipTutorialRequest struct {
	PublicKeyBase58Check string
	JWT                  string
	IsSkip               bool
} 
type GetTxnRequest struct {
	// TxnHash to fetch.
	TxnHashHex string `safeForLogging:"true"`
} 
type GetTxnResponse struct {
	TxnFound bool
} 
type SubmitTransactionRequest struct {
	TransactionHex string `safeForLogging:"true"`
} 
type SubmitTransactionResponse struct {
	Transaction MsgDeSoTxn
	TxnHashHex  string

	// include the PostEntryResponse if a post was submitted
	PostEntryResponse *PostEntryResponse
} 
type UpdateProfileRequest struct {
	// The public key of the user who is trying to update their profile.
	UpdaterPublicKeyBase58Check string `safeForLogging:"true"`

	// This is only set when the user wants to modify a profile
	// that isn't theirs. Otherwise, the UpdaterPublicKeyBase58Check is
	// assumed to own the profile being updated.
	ProfilePublicKeyBase58Check string `safeForLogging:"true"`

	NewUsername    string `safeForLogging:"true"`
	NewDescription string `safeForLogging:"true"`
	// The profile pic string encoded as a link e.g.
	// data:image/png;base64,<data in base64>
	NewProfilePic               string
	NewCreatorBasisPoints       uint64 `safeForLogging:"true"`
	NewStakeMultipleBasisPoints uint64 `safeForLogging:"true"`

	IsHidden bool `safeForLogging:"true"`

	MinFeeRateNanosPerKB uint64 `safeForLogging:"true"`

	// No need to specify ProfileEntryResponse in each TransactionFee
	TransactionFees []TransactionFee `safeForLogging:"true"`
} 
type UpdateProfileResponse struct {
	TotalInputNanos               uint64
	ChangeAmountNanos             uint64
	FeeNanos                      uint64
	Transaction                   MsgDeSoTxn
	TransactionHex                string
	TxnHashHex                    string
	CompProfileCreationTxnHashHex string
} 
type ExchangeBitcoinRequest struct {
	// The public key of the user who we're creating the burn for.
	PublicKeyBase58Check string `safeForLogging:"true"`
	// Note: When BurnAmountSatoshis is negative, we assume that the user wants
	// to burn the maximum amount of satoshi she has available.
	BurnAmountSatoshis   int64 `safeForLogging:"true"`
	FeeRateSatoshisPerKB int64 `safeForLogging:"true"`

	// We rely on the frontend to query the API and give us the response.
	// Doing it this way makes it so that we don't exhaust our quota on the
	// free tier.
	LatestBitcionAPIResponse BlockCypherAPIFullAddressResponse
	// The Bitcoin address we will be processing this transaction for.
	BTCDepositAddress string `safeForLogging:"true"`

	// Whether or not we should broadcast the transaction after constructing
	// it. This will also validate the transaction if it's set.
	// The client must provide SignedHashes which it calculates by signing
	// all the UnsignedHashes in the identity service
	Broadcast bool `safeForLogging:"true"`

	// Signed hashes from the identity service
	// One for each transaction input
	SignedHashes []string
} 
type ExchangeBitcoinResponse struct {
	TotalInputSatoshis   uint64
	BurnAmountSatoshis   uint64
	ChangeAmountSatoshis uint64
	FeeSatoshis          uint64
	BitcoinTransaction   *wire.MsgTx

	SerializedTxnHex string
	TxnHashHex       string
	DeSoTxnHashHex   string

	UnsignedHashes []string
} 
type SendDeSoRequest struct {
	SenderPublicKeyBase58Check   string `safeForLogging:"true"`
	RecipientPublicKeyOrUsername string `safeForLogging:"true"`
	AmountNanos                  int64  `safeForLogging:"true"`
	MinFeeRateNanosPerKB         uint64 `safeForLogging:"true"`

	// No need to specify ProfileEntryResponse in each TransactionFee
	TransactionFees []TransactionFee `safeForLogging:"true"`
} 
type SendDeSoResponse struct {
	TotalInputNanos          uint64
	SpendAmountNanos         uint64
	ChangeAmountNanos        uint64
	FeeNanos                 uint64
	TransactionIDBase58Check string
	Transaction              MsgDeSoTxn
	TransactionHex           string
	TxnHashHex               string
} 
type CreateLikeStatelessRequest struct {
	ReaderPublicKeyBase58Check string `safeForLogging:"true"`
	LikedPostHashHex           string `safeForLogging:"true"`
	IsUnlike                   bool   `safeForLogging:"true"`
	MinFeeRateNanosPerKB       uint64 `safeForLogging:"true"`

	// No need to specify ProfileEntryResponse in each TransactionFee
	TransactionFees []TransactionFee `safeForLogging:"true"`
} 
type CreateLikeStatelessResponse struct {
	TotalInputNanos   uint64
	ChangeAmountNanos uint64
	FeeNanos          uint64
	Transaction       MsgDeSoTxn
	TransactionHex    string
} 
type SubmitPostRequest struct {
	// The public key of the user who made the post or the user
	// who is subsequently is modifying the post.
	UpdaterPublicKeyBase58Check string `safeForLogging:"true"`

	// Optional. Set when modifying a post as opposed to creating one
	// from scratch.
	PostHashHexToModify string `safeForLogging:"true"`

	// The parent post or profile. This is used for comments.
	ParentStakeID string `safeForLogging:"true"`
	// The body of this post.
	BodyObj DeSoBodySchema

	// The PostHashHex of the post being reposted
	RepostedPostHashHex string `safeForLogging:"true"`

	// ExtraData object to hold arbitrary attributes of a post.
	PostExtraData map[string]string `safeForLogging:"true"`

	// When set to true the post will be hidden.
	IsHidden bool `safeForLogging:"true"`

	MinFeeRateNanosPerKB uint64 `safeForLogging:"true"`

	// No need to specify ProfileEntryResponse in each TransactionFee
	TransactionFees []TransactionFee `safeForLogging:"true"`

	InTutorial bool `safeForLogging:"true"`
} 
type SubmitPostResponse struct {
	TstampNanos uint64 `safeForLogging:"true"`
	PostHashHex string `safeForLogging:"true"`

	TotalInputNanos   uint64
	ChangeAmountNanos uint64
	FeeNanos          uint64
	Transaction       MsgDeSoTxn
	TransactionHex    string
} 
type CreateFollowTxnStatelessRequest struct {
	FollowerPublicKeyBase58Check string `safeForLogging:"true"`
	FollowedPublicKeyBase58Check string `safeForLogging:"true"`
	IsUnfollow                   bool   `safeForLogging:"true"`
	MinFeeRateNanosPerKB         uint64 `safeForLogging:"true"`

	// No need to specify ProfileEntryResponse in each TransactionFee
	TransactionFees []TransactionFee `safeForLogging:"true"`
} 
type CreateFollowTxnStatelessResponse struct {
	TotalInputNanos   uint64
	ChangeAmountNanos uint64
	FeeNanos          uint64
	Transaction       MsgDeSoTxn
	TransactionHex    string
} 
type BuyOrSellCreatorCoinRequest struct {
	// The public key of the user who is making the buy/sell.
	UpdaterPublicKeyBase58Check string `safeForLogging:"true"`

	// The public key of the profile that the purchaser is trying
	// to buy.
	CreatorPublicKeyBase58Check string `safeForLogging:"true"`

	// Whether this is a "buy" or "sell"
	OperationType string `safeForLogging:"true"`

	// Generally, only one of these will be used depending on the OperationType
	// set. In a Buy transaction, DeSoToSellNanos will be converted into
	// creator coin on behalf of the user. In a Sell transaction,
	// CreatorCoinToSellNanos will be converted into DeSo. In an AddDeSo
	// operation, DeSoToAddNanos will be aded for the user. This allows us to
	// support multiple transaction types with same meta field.
	DeSoToSellNanos        uint64 `safeForLogging:"true"`
	CreatorCoinToSellNanos uint64 `safeForLogging:"true"`
	DeSoToAddNanos         uint64 `safeForLogging:"true"`

	// When a user converts DeSo into CreatorCoin, MinCreatorCoinExpectedNanos
	// specifies the minimum amount of creator coin that the user expects from their
	// transaction. And vice versa when a user is converting CreatorCoin for DeSo.
	// Specifying these fields prevents the front-running of users' buy/sell. Setting
	// them to zero turns off the check. Give it your best shot, Ivan.
	MinDeSoExpectedNanos        uint64 `safeForLogging:"true"`
	MinCreatorCoinExpectedNanos uint64 `safeForLogging:"true"`

	MinFeeRateNanosPerKB uint64 `safeForLogging:"true"`

	// No need to specify ProfileEntryResponse in each TransactionFee
	TransactionFees []TransactionFee `safeForLogging:"true"`

	InTutorial bool `safeForLogging:"true"`

	BitCloutToSellNanos      uint64 `safeForLogging:"true"` // Deprecated
	BitCloutToAddNanos       uint64 `safeForLogging:"true"` // Deprecated
	MinBitCloutExpectedNanos uint64 `safeForLogging:"true"` // Deprecated
} 
type BuyOrSellCreatorCoinResponse struct {
	// The amount of DeSo
	ExpectedDeSoReturnedNanos        uint64
	ExpectedCreatorCoinReturnedNanos uint64
	FounderRewardGeneratedNanos      uint64

	// Spend is defined as DeSo that's specified as input that winds up as "output not
	// belonging to you." In the case of a creator coin sell, your input is creator coin (not
	// DeSo), so this ends up being 0. In the case of a creator coin buy,
	// it should equal the amount of DeSo you put in to buy the creator coin
	SpendAmountNanos  uint64
	TotalInputNanos   uint64
	ChangeAmountNanos uint64
	FeeNanos          uint64
	Transaction       MsgDeSoTxn
	TransactionHex    string
	TxnHashHex        string
} 
type TransferCreatorCoinRequest struct {
	// The public key of the user who is making the transfer.
	SenderPublicKeyBase58Check string `safeForLogging:"true"`

	// The public key of the profile for the creator coin that the user is transferring.
	CreatorPublicKeyBase58Check string `safeForLogging:"true"`

	// The public key or username of the user receiving the transferred creator coin.
	ReceiverUsernameOrPublicKeyBase58Check string `safeForLogging:"true"`

	// The amount of creator coins to transfer in nanos.
	CreatorCoinToTransferNanos uint64 `safeForLogging:"true"`

	MinFeeRateNanosPerKB uint64 `safeForLogging:"true"`

	// No need to specify ProfileEntryResponse in each TransactionFee
	TransactionFees []TransactionFee `safeForLogging:"true"`
} 
type TransferCreatorCoinResponse struct {
	SpendAmountNanos  uint64
	TotalInputNanos   uint64
	ChangeAmountNanos uint64
	FeeNanos          uint64
	Transaction       MsgDeSoTxn
	TransactionHex    string
	TxnHashHex        string
} 
type SendDiamondsRequest struct {
	// The public key of the user who is making the transfer.
	SenderPublicKeyBase58Check string `safeForLogging:"true"`

	// The public key or username of the user receiving the transferred creator coin.
	ReceiverPublicKeyBase58Check string `safeForLogging:"true"`

	// The number of diamonds to give the post.
	DiamondPostHashHex string `safeForLogging:"true"`

	// The number of diamonds to give the post.
	DiamondLevel int64 `safeForLogging:"true"`

	MinFeeRateNanosPerKB uint64 `safeForLogging:"true"`

	// No need to specify ProfileEntryResponse in each TransactionFee
	TransactionFees []TransactionFee `safeForLogging:"true"`

	InTutorial bool `safeForLogging:"true"`
} 
type SendDiamondsResponse struct {
	SpendAmountNanos  uint64
	TotalInputNanos   uint64
	ChangeAmountNanos uint64
	FeeNanos          uint64
	Transaction       MsgDeSoTxn
	TransactionHex    string
	TxnHashHex        string
} 
type DAOCoinRequest struct {
	// The public key of the user who is performing the DAOCoin Txn
	UpdaterPublicKeyBase58Check string `safeForLogging:"true"`

	// The public key or username of the profile whose DAO coin the transactor is trying to transact with.
	ProfilePublicKeyBase58CheckOrUsername string `safeForLogging:"true"`

	// Whether this is a "mint", "burn" or "disable_minting" transaction
	OperationType DAOCoinOperationTypeString `safeForLogging:"true"`

	// Coins
	CoinsToMintNanos uint256.Int `safeForLogging:"true"`

	CoinsToBurnNanos uint256.Int `safeForLogging:"true"`

	// Transfer Restriction Status
	TransferRestrictionStatus TransferRestrictionStatusString `safeForLogging:"true"`

	MinFeeRateNanosPerKB uint64 `safeForLogging:"true"`

	// No need to specify ProfileEntryResponse in each TransactionFee
	TransactionFees []TransactionFee `safeForLogging:"true"`
} 
type DAOCoinResponse struct {
	TotalInputNanos   uint64
	ChangeAmountNanos uint64
	FeeNanos          uint64
	Transaction       MsgDeSoTxn
	TransactionHex    string
	TxnHashHex        string
} 
type TransferDAOCoinRequest struct {
	// The public key of the user who is making the transfer.
	SenderPublicKeyBase58Check string `safeForLogging:"true"`

	// The public key/Username of the profile for the DAO coin that the user is transferring.
	ProfilePublicKeyBase58CheckOrUsername string `safeForLogging:"true"`

	// The public key/username of the user receiving the transferred creator coin.
	ReceiverPublicKeyBase58CheckOrUsername string `safeForLogging:"true"`

	// The amount of creator coins to transfer in nanos.
	DAOCoinToTransferNanos uint256.Int `safeForLogging:"true"`

	MinFeeRateNanosPerKB uint64 `safeForLogging:"true"`

	// No need to specify ProfileEntryResponse in each TransactionFee
	TransactionFees []TransactionFee `safeForLogging:"true"`
} 
type TransferDAOCoinResponse struct {
	SpendAmountNanos  uint64
	TotalInputNanos   uint64
	ChangeAmountNanos uint64
	FeeNanos          uint64
	Transaction       MsgDeSoTxn
	TransactionHex    string
	TxnHashHex        string
} 
type AuthorizeDerivedKeyRequest struct {
	// The original public key of the derived key owner.
	OwnerPublicKeyBase58Check string `safeForLogging:"true"`

	// The derived public key
	DerivedPublicKeyBase58Check string `safeForLogging:"true"`

	// The expiration block of the derived key pair.
	ExpirationBlock uint64 `safeForLogging:"true"`

	// The signature of hash(derived key + expiration block) made by the owner.
	AccessSignature string `safeForLogging:"true"`

	// The intended operation on the derived key.
	DeleteKey bool `safeForLogging:"true"`

	// If we intend to sign this transaction with a derived key.
	DerivedKeySignature bool `safeForLogging:"true"`

	// No need to specify ProfileEntryResponse in each TransactionFee
	TransactionFees []TransactionFee `safeForLogging:"true"`

	MinFeeRateNanosPerKB uint64 `safeForLogging:"true"`
} 
type AuthorizeDerivedKeyResponse struct {
	SpendAmountNanos  uint64
	TotalInputNanos   uint64
	ChangeAmountNanos uint64
	FeeNanos          uint64
	Transaction       MsgDeSoTxn
	TransactionHex    string
	TxnHashHex        string
} 
type AppendExtraDataRequest struct {
	// Transaction hex.
	TransactionHex string `safeForLogging:"true"`

	// ExtraData object.
	ExtraData map[string]string `safeForLogging:"true"`
} 
type AppendExtraDataResponse struct {
	// Final Transaction hex.
	TransactionHex string `safeForLogging:"true"`
} 
type GetTransactionSpendingRequest struct {
	// Transaction hex.
	TransactionHex string `safeForLogging:"true"`
} 
type GetTransactionSpendingResponse struct {
	// Total transaction spending in nanos.
	TotalSpendingNanos uint64 `safeForLogging:"true"`
} 
type DAOCoinOperationTypeString string 
type TransferRestrictionStatusString string 
type GetUsersStatelessRequest struct {
	PublicKeysBase58Check []string `safeForLogging:"true"`
	SkipForLeaderboard    bool     `safeForLogging:"true"`
	GetUnminedBalance     bool     `safeForLogging:"true"`
} 
type GetUsersResponse struct {
	UserList                 []*User
	DefaultFeeRateNanosPerKB uint64
	ParamUpdaters            map[string]bool
} 
type GetUserMetadataRequest struct {
	PublicKeyBase58Check string
} 
type GetUserMetadataResponse struct {
	HasPhoneNumber   bool
	CanCreateProfile bool
	BlockedPubKeys   map[string]struct{}
	HasEmail         bool
	EmailVerified    bool
	// JumioFinishedTime = Time user completed flow in Jumio
	JumioFinishedTime uint64
	// JumioVerified = user was verified from Jumio flow
	JumioVerified bool
	// JumioReturned = jumio webhook called
	JumioReturned bool
} 
type GetProfilesRequest struct {
	// When set, we return profiles starting at the given pubkey up to numEntriesToReturn.
	PublicKeyBase58Check string `safeForLogging:"true"`
	// When set, we return profiles starting at the given username up to numEntriesToReturn.
	Username string `safeForLogging:"true"`
	// When specified, we filter out all profiles that don't have this
	// string as a prefix on their username.
	UsernamePrefix string `safeForLogging:"true"`
	// When set, we filter out profiles that don't contain this string
	// in their Description field.
	Description string `safeForLogging:"true"`
	OrderBy     string `safeForLogging:"true"`
	NumToFetch  uint32 `safeForLogging:"true"`
	// Public key of the user viewing the profile (affects post entry reader state).
	ReaderPublicKeyBase58Check string `safeForLogging:"true"`
	// Moderation type (currently empty string or 'leaderboard'). Empty string is for default
	// moderation.  'Leaderboard' is a special subset of profiles only removed from the leaderboards.
	ModerationType string `safeForLogging:"true"`
	// If a single profile is requested, return a list of HODLers and amount they HODL.
	FetchUsersThatHODL bool `safeForLogging:"true"`

	// If set to true, then the posts in the response will contain a boolean about whether they're in the global feed
	AddGlobalFeedBool bool `safeForLogging:"true"`
} 
type GetProfilesResponse struct {
	ProfilesFound []*ProfileEntryResponse
	NextPublicKey *string
} 
type ProfileEntryResponse struct {
	// PublicKey is the key used by the user to sign for things and generally
	// verify her identity.
	PublicKeyBase58Check string
	Username             string
	Description          string
	IsHidden             bool
	IsReserved           bool
	IsVerified           bool
	Comments             []*PostEntryResponse
	Posts                []*PostEntryResponse
	// Creator coin fields
	CoinEntry *CoinEntryResponse

	// DAO Coin fields
	DAOCoinEntry *DAOCoinEntryResponse

	// Include current price for the frontend to display.
	CoinPriceDeSoNanos     uint64
	CoinPriceBitCloutNanos uint64 // Deprecated

	// Profiles of users that hold the coin + their balances.
	UsersThatHODL []*BalanceEntryResponse

	// If user is featured as a well known creator in the tutorial.
	IsFeaturedTutorialWellKnownCreator bool
	// If user is featured as an up and coming creator in the tutorial.
	// Note: a user should not be both featured as well known and up and coming
	IsFeaturedTutorialUpAndComingCreator bool
} 
type CoinEntryResponse struct {
	CreatorBasisPoints        uint64
	DeSoLockedNanos           uint64
	NumberOfHolders           uint64
	CoinsInCirculationNanos   uint64
	CoinWatermarkNanos        uint64

	// Deprecated: Temporary to add support for BitCloutLockedNanos
	BitCloutLockedNanos uint64 // Deprecated
} 
type DAOCoinEntryResponse struct {
	NumberOfHolders           uint64
	CoinsInCirculationNanos   uint256.Int
	MintingDisabled           bool
	TransferRestrictionStatus TransferRestrictionStatusString
} 
type GetSingleProfileRequest struct {
	// When set, we return profiles starting at the given pubkey up to numEntriesToReturn.
	PublicKeyBase58Check string `safeForLogging:"true"`
	// When set, we return profiles starting at the given username up to numEntriesToReturn.
	Username string `safeForLogging:"true"`
	// When true, we don't log a 404 for missing profiles
	NoErrorOnMissing bool `safeForLogging:"true"`
} 
type GetSingleProfileResponse struct {
	Profile       *ProfileEntryResponse
	IsBlacklisted bool
	IsGraylisted  bool
} 
type GetHodlersForPublicKeyRequest struct {
	// Either PublicKeyBase58Check or Username can be set by the client to specify
	// which user we're obtaining posts for
	// If both are specified, PublicKeyBase58Check will supercede
	PublicKeyBase58Check string `safeForLogging:"true"`
	Username             string `safeForLogging:"true"`

	// Public Key of the last post from the previous page
	LastPublicKeyBase58Check string `safeForLogging:"true"`
	// Number of records to fetch
	NumToFetch uint64 `safeForLogging:"true"`

	// If true, fetch DAO coin balance entries instead of creator coin balance entries
	IsDAOCoin bool `safeForLogging:"true"`

	// If true, fetch balance entries for your hodlings instead of balance entries for hodler's of your coin
	FetchHodlings bool

	// If true, fetch all hodlers/hodlings -- supercedes NumToFetch
	FetchAll bool
} 
type GetHodlersForPublicKeyResponse struct {
	Hodlers                  []*BalanceEntryResponse
	LastPublicKeyBase58Check string
} 
type DiamondSenderSummaryResponse struct {
	SenderPublicKeyBase58Check   string
	ReceiverPublicKeyBase58Check string

	TotalDiamonds       uint64
	HighestDiamondLevel uint64

	DiamondLevelMap      map[uint64]uint64
	ProfileEntryResponse *ProfileEntryResponse
} 
type GetDiamondsForPublicKeyRequest struct {
	// The user we are getting diamonds for.
	PublicKeyBase58Check string `safeForLogging:"true"`

	// If true, fetch the diamonds this public key gave out instead of the diamond this public key received
	FetchYouDiamonded bool
} 
type GetDiamondsForPublicKeyResponse struct {
	DiamondSenderSummaryResponses []*DiamondSenderSummaryResponse
	TotalDiamonds                 uint64
} 
type GetFollowsStatelessRequest struct {
	// Either PublicKeyBase58Check or Username can be set by the client to specify
	// which user we're obtaining follows for
	// If both are specified, PublicKeyBase58Check will supercede
	PublicKeyBase58Check        string `safeForLogging:"true"`
	Username                    string `safeForLogging:"true"`
	GetEntriesFollowingUsername bool   `safeForLogging:"true"`

	// Public Key of the last follower / followee from the previous page
	LastPublicKeyBase58Check string `safeForLogging:"true"`
	// Number of records to fetch
	NumToFetch uint64 `safeForLogging:"true"`
} 
type GetFollowsResponse struct {
	PublicKeyToProfileEntry map[string]*ProfileEntryResponse `safeForLogging:"true"`
	NumFollowers            uint64
} 
type GetUserGlobalMetadataRequest struct {
	// The public key of the user who is trying to update their metadata.
	UserPublicKeyBase58Check string `safeForLogging:"true"`

	// JWT token authenticates the user
	JWT string
} 
type GetUserGlobalMetadataResponse struct {
	Email       string
	PhoneNumber string
} 
type UpdateUserGlobalMetadataRequest struct {
	// The public key of the user who is trying to update their metadata.
	UserPublicKeyBase58Check string `safeForLogging:"true"`

	// JWT token authenticates the user
	JWT string

	// User's email for receiving notifications.
	Email string

	// A map of ContactPublicKeyBase58Check keys and number of read messages int values.
	MessageReadStateUpdatesByContact map[string]int
} 
type GetNotificationsCountRequest struct {
	PublicKeyBase58Check string
} 
type GetNotificationsCountResponse struct {
	NotificationsCount          uint64
	LastUnreadNotificationIndex uint64
	// Whether new unread notifications were added and the user metadata should be updated
	UpdateMetadata bool
} 
type GetNotificationsRequest struct {
	// This is the index of the notification we want to start our paginated lookup at. We
	// will fetch up to "NumToFetch" notifications after it, ordered by index.  If no
	// index is provided we will return the most recent posts.
	PublicKeyBase58Check string
	FetchStartIndex      int64
	NumToFetch           int64
	// This defines notifications that should be filtered OUT of the response
	// If a field is missing from this struct, it should be included in the response
	// Accepted values are like, diamond, follow, transfer, nft, post
	FilteredOutNotificationCategories map[string]bool
} 
type GetNotificationsResponse struct {
	Notifications       []*TransactionMetadataResponse
	ProfilesByPublicKey map[string]*ProfileEntryResponse
	PostsByHash         map[string]*PostEntryResponse
	LastSeenIndex       int64
} 
type SetNotificationMetadataRequest struct {
	PublicKeyBase58Check string
	// The last notification index the user has seen
	LastSeenIndex int64
	// The last notification index that has been scanned
	LastUnreadNotificationIndex int64
	// The total count of unread notifications
	UnreadNotifications int64
	// JWT token
	JWT string
} 
type TransactionMetadataResponse struct {
	Metadata           TransactionMetadata
	TxnOutputResponses []*OutputResponse
	Txn                *TransactionResponse
	Index              int64
} 
type BlockPublicKeyRequest struct {
	PublicKeyBase58Check      string
	BlockPublicKeyBase58Check string
	Unblock                   bool
	JWT                       string
} 
type BlockPublicKeyResponse struct {
	BlockedPublicKeys map[string]struct{}
} 
type IsFollowingPublicKeyRequest struct {
	PublicKeyBase58Check            string
	IsFollowingPublicKeyBase58Check string
} 
type IsFolllowingPublicKeyResponse struct {
	IsFollowing bool
} 
type IsHodlingPublicKeyRequest struct {
	PublicKeyBase58Check          string
	IsHodlingPublicKeyBase58Check string
	IsDAOCoin                     bool
} 
type IsHodlingPublicKeyResponse struct {
	IsHodling    bool
	BalanceEntry *BalanceEntryResponse
} 
type GetUserDerivedKeysRequest struct {
	// Public key which derived keys we want to query.
	PublicKeyBase58Check string `safeForLogging:"true"`
} 
type UserDerivedKey struct {
	// This is the public key of the owner.
	OwnerPublicKeyBase58Check string `safeForLogging:"true"`

	// This is the derived public key.
	DerivedPublicKeyBase58Check string `safeForLogging:"true"`

	// This is the expiration date of the derived key.
	ExpirationBlock uint64 `safeForLogging:"true"`

	// This is the current state of the derived key.
	IsValid bool `safeForLogging:"true"`
} 
type GetUserDerivedKeysResponse struct {
	// DerivedKeys contains user's derived keys indexed by public keys in base58Check
	DerivedKeys map[string]*UserDerivedKey `safeForLogging:"true"`
} 
type DeletePIIRequest struct {
	PublicKeyBase58Check string
	JWT                  string
} 
type GlobalState struct {
	GlobalStateRemoteNode   string
	GlobalStateRemoteSecret string
	GlobalStateDB           *badger.DB
} 
type HotFeedApprovedPostOp struct {
	IsRemoval  bool
	Multiplier float64 // Negatives are ignored when updating the ApprovedPosts map.
} 
type HotFeedPKIDMultiplierOp struct {
	InteractionMultiplier float64 // Negatives are ignored when updating the PKIDMultiplier map.
	PostsMultiplier       float64 // Negatives are ignored when updating the PKIDMultiplier map.
} 
type ReferralInfo struct {
	ReferralHashBase58     string
	ReferrerPKID           PKID
	ReferrerAmountUSDCents uint64
	RefereeAmountUSDCents  uint64
	MaxReferrals           uint64 // If set to zero, there is no cap on referrals.
	RequiresJumio          bool

	// Stats
	NumJumioAttempts       uint64
	NumJumioSuccesses      uint64
	TotalReferrals         uint64
	TotalReferrerDeSoNanos uint64
	TotalRefereeDeSoNanos  uint64
	DateCreatedTStampNanos uint64
} 
type SimpleReferralInfo struct {
	ReferralHashBase58    string
	RefereeAmountUSDCents uint64
	MaxReferrals          uint64 // If set to zero, there is no cap on referrals.
	TotalReferrals        uint64
} 
type NFTDropEntry struct {
	IsActive        bool
	DropNumber      uint64
	DropTstampNanos uint64
	NFTHashes       []BlockHash
} 
type UserMetadata struct {
	// The PublicKey of the user this metadata is associated with.
	PublicKey []byte

	// True if this user should be hidden from all data returned to the app.
	RemoveEverywhere bool

	// True if this user should be hidden from the creator leaderboard.
	RemoveFromLeaderboard bool

	// Email address for a user to receive email notifications at.
	Email string

	// Has the email been verified
	EmailVerified bool

	// E.164 format phone number for a user to receive text notifications at.
	PhoneNumber string

	// Country code associated with the user's phone number. This is a string like "US"
	PhoneNumberCountryCode string

	// This map stores the number of messages that a user has read from a specific contact.
	// The map is indexed with the contact's PublicKeyBase58Check and maps to an integer
	// number of messages that the user has read.
	MessageReadStateByContact map[string]int

	// Store the index of the last notification that the user saw
	NotificationLastSeenIndex int64

	// Amount of Bitcoin that users have burned so far via the Buy DeSo UI
	//
	// We track this so that, if the user does multiple burns,
	// we can set HasBurnedEnoughSatoshisToCreateProfile based on the total
	//
	// This tracks the "total input satoshis" (i.e. it includes fees the user spends).
	// Including fees makes it less expensive for a user to make a profile. We're cutting
	// users a break, but we could change this later.
	SatoshisBurnedSoFar uint64

	// True if the user has burned enough satoshis to create a profile. This can be
	// set to true from the BurnBitcoinStateless endpoint or canUserCreateProfile.
	//
	// We store this (instead of computing it when the user loads the page) to avoid issues
	// where the user burns the required amount, and then we reboot the node and change the min
	// satoshis required, and then the user hasn't burned enough. Once a user has burned enough,
	// we want him to be allowed to create a profile forever.
	HasBurnedEnoughSatoshisToCreateProfile bool

	// Map of public keys of profiles this user has blocked.  The map here functions as a hashset to make look ups more
	// efficient.  Values are empty structs to keep memory usage down.
	BlockedPublicKeys map[string]struct{}

	// If true, this user's posts will automatically be added to the global whitelist (max 5 per day).
	WhitelistPosts bool

	// JumioInternalReference = internal tracking reference for user's experience in Jumio
	JumioInternalReference string
	// JumioFinishedTime = has user completed flow in Jumio
	JumioFinishedTime uint64
	// JumioVerified = user was verified from Jumio flow
	JumioVerified bool
	// JumioReturned = jumio webhook called
	JumioReturned bool
	// JumioTransactionID = jumio's tracking number for the transaction in which this user was verified.
	JumioTransactionID string
	// JumioDocumentKey = Country - Document Type - Document SubType - Document Number. Helps uniquely identify users
	// and allows us to reset Jumio for a given user.
	// DEPRECATED
	JumioDocumentKey []byte
	// RedoJumio = boolean which allows user to skip the duplicate ID check in JumioCallback
	RedoJumio bool
	// JumioStarterDeSoTxnHashHex = Txn hash hex of the transaction in which the user was paid for
	// going through the Jumio flow
	JumioStarterDeSoTxnHashHex string
	// JumioShouldCompProfileCreation = True if we should comp the create profile fee because the user went through the
	// Jumio flow.
	JumioShouldCompProfileCreation bool

	// User must complete tutorial if they have been jumio verified.
	MustCompleteTutorial bool

	// If user is featured as a well known creator in the tutorial.
	IsFeaturedTutorialWellKnownCreator bool
	// If user is featured as an up and coming creator in the tutorial.
	// Note: a user should not be both featured as well known and up and coming
	IsFeaturedTutorialUpAndComingCreator bool

	TutorialStatus                  TutorialStatus
	CreatorPurchasedInTutorialPKID  PKID
	CreatorCoinsPurchasedInTutorial uint64

	// ReferralHashBase58Check with which user signed up
	ReferralHashBase58Check string

	// Txn hash in which the referrer was paid
	ReferrerDeSoTxnHash string

	// The number of unread notifications stored in the db.
	UnreadNotifications uint64
	// The most recently scanned notification transaction index in the database. Stored in order to prevent unnecessary re-scanning.
	LatestUnreadNotificationIndex int64
} 
type PhoneNumberMetadata struct {
	// The PublicKey of the user that this phone number belongs to.
	PublicKey []byte

	// E.164 format phone number for a user to receive text notifications at.
	PhoneNumber string

	// Country code associated with the user's phone number.
	PhoneNumberCountryCode string

	// if true, when the public key associated with this metadata tries to create a profile, we will comp their fee.
	ShouldCompProfileCreation bool

	// True if user deleted PII. Since users can
	PublicKeyDeleted bool
} 
type WyreWalletOrderMetadata struct {
	// Last payload received from Wyre webhook
	LatestWyreWalletOrderWebhookPayload WyreWalletOrderWebhookPayload

	// Track Wallet Order response received based on the last payload received from Wyre Webhook
	LatestWyreTrackWalletOrderResponse *WyreTrackOrderResponse

	// Amount of DeSo that was sent for this WyreWalletOrder
	DeSoPurchasedNanos uint64

	// BlockHash of the transaction for sending the DeSo
	BasicTransferTxnBlockHash BlockHash
} 
type CountryLevelSignUpBonus struct {
	// If true, referee amount specified in referral code will be paid to users who sign up with IDs from this country.
	// If false, ReferralAmountOverrideUSDCents will be paid to users who sign up with IDs from this country.
	AllowCustomReferralAmount bool
	// Amount all referees will be paid when signing up from this country if AllowCustomReferralAmount is false.
	ReferralAmountOverrideUSDCents uint64
	// If true, referrer amount specified in referral code will be paid as a kickback to users who gave out referral
	// code that a user signed up with IDs from this country.
	// If false, KickbackAmountOverrideUSDCents will be paid as a kickback to referrers when a user signs up with an ID
	// from this country.
	AllowCustomKickbackAmount bool
	// Amount all referrers will be paid when a referee signs up from this country if AllowCustomKickbackAmount is
	// false.
	KickbackAmountOverrideUSDCents uint64
} 
type PutRemoteRequest struct {
	Key   []byte
	Value []byte
} 
type PutRemoteResponse struct {
} 
type GetRemoteRequest struct {
	Key []byte
} 
type GetRemoteResponse struct {
	Value []byte
} 
type BatchGetRemoteRequest struct {
	KeyList [][]byte
} 
type BatchGetRemoteResponse struct {
	ValueList [][]byte
} 
type DeleteRemoteRequest struct {
	Key []byte
} 
type DeleteRemoteResponse struct {
} 
type SeekRemoteRequest struct {
	StartPrefix    []byte
	ValidForPrefix []byte
	MaxKeyLen      int
	NumToFetch     int
	Reverse        bool
	FetchValues    bool
} 
type SeekRemoteResponse struct {
	KeysFound [][]byte
	ValsFound [][]byte
} 
type TutorialStatus string 
type HelpConnectNFTSoldStruct struct {
	NFTPostHash     *BlockHash
	SerialNumber    uint64
	BidderPKID      *PKID
	BidAmountNanos  uint64
	UnlockableText  []byte
	PrevNFTBidEntry *NFTBidEntry

	// When an NFT owner accepts a bid, they must specify the bidder's UTXO inputs they will lock up
	// as payment for the purchase. This prevents the transaction from accidentally using UTXOs
	// that are used by future transactions.
	BidderInputs []*DeSoInput

	BlockHeight      uint32
	Txn              *MsgDeSoTxn
	TxHash           *BlockHash
	VerifySignatures bool
} 
type HotFeedEntry struct {
	PostHash     BlockHash
	PostHashHex  string
	HotnessScore uint64
} 
type HotFeedInteractionKey struct {
	InteractionPKID     lib.PKID
	InteractionPostHash lib.BlockHash
} 
type HotFeedPKIDMultiplier struct {
	// A multiplier applied to the score that each user interaction adds to a post.
	InteractionMultiplier float64
	// A multiplier applied to all posts from this specific PKID.
	PostsMultiplier float64
} 
type HotnessPostInfo struct {
	// How long ago the post was created in number of blocks
	PostBlockAge int
	HotnessScore uint64
} 
type HotFeedPageRequest struct {
	ReaderPublicKeyBase58Check string
	// Since the hot feed is constantly changing, we pass a list of posts that have already
	// been seen in order to send a more accurate next page.
	SeenPosts []string
	// Number of post entry responses to return.
	ResponseLimit int
} 
type HotFeedPageResponse struct {
	HotFeedPage []PostEntryResponse
} 
type AdminUpdateHotFeedAlgorithmRequest struct {
	// Maximum score amount that any individual PKID can contribute to the hot feed score
	// before time decay. Ignored if set to zero.
	InteractionCap int
	// Number of blocks per halving for the hot feed score time decay. Ignored if set to zero.
	TimeDecayBlocks int
} 
type AdminGetHotFeedAlgorithmResponse struct {
	InteractionCap  uint64
	TimeDecayBlocks uint64
} 
type AdminUpdateHotFeedPostMultiplierRequest struct {
	PostHashHex string  `safeforlogging:"true"`
	Multiplier  float64 `safeforlogging:"true"`
} 
type AdminUpdateHotFeedUserMultiplierRequest struct {
	Username              string  `safeforlogging:"true"`
	InteractionMultiplier float64 `safeforlogging:"true"`
	PostsMultiplier       float64 `safeforlogging:"true"`
} 
type AdminGetHotFeedUserMultiplierRequest struct {
	Username string `safeforlogging:"true"`
} 
type AdminGetHotFeedUserMultiplierResponse struct {
	InteractionMultiplier float64 `safeforlogging:"true"`
	PostsMultiplier       float64 `safeforlogging:"true"`
} 
type MempoolTx struct {
	Tx *MsgDeSoTxn

	// TxMeta is the transaction metadata
	TxMeta *TransactionMetadata

	// Hash is a hash of the transaction so we don't have to recompute
	// it all the time.
	Hash *BlockHash

	// TxSizeBytes is the cached size of the transaction.
	TxSizeBytes uint64

	// The time when the txn was added to the pool
	Added time.Time

	// The block height when the txn was added to the pool. It's generally set
	// to tip+1.
	Height uint32

	// The total fee the txn pays. Cached for efficiency reasons.
	Fee uint64

	// The fee rate of the transaction in nanos per KB.
	FeePerKB uint64

	// index is used by the heap logic to allow for modification in-place.
	index int
} 
type SummaryStats struct {
	// Number of transactions of this type in the mempool.
	Count uint32

	// Number of bytes for transactions of this type in the mempool.
	TotalBytes uint64
} 
type UnconnectedTx struct {
	tx *MsgDeSoTxn
	// The ID of the Peer who initially sent the unconnected txn. Useful for
	// removing unconnected transactions when a Peer disconnects.
	peerID     uint64
	expiration time.Time
} 
type DeSoMempool struct {
	// Stops the mempool's services.
	quit chan struct{}

	// A reference to a blockchain object that can be used to validate transactions before
	// adding them to the pool.
	bc *Blockchain

	// Transactions with a feerate below this threshold are outright rejected.
	minFeeRateNanosPerKB uint64

	// rateLimitFeeRateNanosPerKB defines the minimum transaction feerate in "nanos per KB"
	// before a transaction is considered for rate-limiting. Note that even if a
	// transaction with a feerate below this threshold is not rate-limited, it must
	// still have a high enough feerate to be considered as part of the mempool.
	rateLimitFeeRateNanosPerKB uint64

	mtx deadlock.RWMutex

	// poolMap contains all of the transactions that have been validated by the pool.
	// Transactions in poolMap should be directly consumable by a miner and formed into
	// a block by taking them in order of when they were Added.
	poolMap map[BlockHash]*MempoolTx
	// txFeeMinHeap organizes transactions stored in poolMap by their FeePerKB. It is used
	// in order to prevent the pool from exhausing memory due to having to store too
	// many low-fee transactions.
	// totalTxSizeBytes is the total size of all of the transactions stored in poolMap. We
	// use it to determine when the pool is nearing memory-exhaustion so we can start
	// evicting transactions.
	totalTxSizeBytes uint64
	// Stores the inputs for every transaction stored in poolMap. Used to quickly check
	// if a transaction is double-spending.
	outpoints map[UtxoKey]*MsgDeSoTxn
	// Unconnected contains transactions whose inputs reference UTXOs that are not yet
	// present in either our UTXO database or the transactions stored in pool.
	unconnectedTxns map[BlockHash]*UnconnectedTx
	// Organizes unconnectedTxns by their UTXOs. Used when adding a transaction to determine
	// which unconnectedTxns are no longer missing parents.
	unconnectedTxnsByPrev map[UtxoKey]map[BlockHash]*MsgDeSoTxn
	// An exponentially-decayed accumulator of "low-fee" transactions we've relayed.
	// This is used to prevent someone from flooding the network with low-fee
	// transactions.
	lowFeeTxSizeAccumulator float64
	// The UNIX time (in seconds) when the last "low-fee" transaction was relayed.
	lastLowFeeTxUnixTime int64

	// pubKeyToTxnMap stores a mapping from the public key of outputs added
	// to the mempool to the corresponding transaction that resulted in their
	// addition. It is useful for figuring out how much DeSo a particular public
	// key has available to spend.
	pubKeyToTxnMap map[PkMapKey]map[BlockHash]*MempoolTx

	// The next time the unconnectTxn pool will be scanned for expired unconnectedTxns.
	nextExpireScan time.Time

	// Optional. When set, we use the BlockCypher API to detect double-spends.
	blockCypherAPIKey string

	// These two views are used to check whether a transaction is valid before
	// adding it to the mempool. This is done by applying the transaction to the
	// backup view, and then restoring the backup view if there's an error. In
	// the future, if we can figure out an easy way to rollback bad transactions
	// on a single view, then we won't need the second view anymore.
	backupUniversalUtxoView  *UtxoView
	universalUtxoView        *UtxoView
	universalTransactionList []*MempoolTx

	// When set, transactions are initially read from this dir and dumped
	// to this dir.
	mempoolDir string

	// Whether or not we should be computing readOnlyUtxoViews.
	generateReadOnlyUtxoView bool
	// A view that contains a *near* up-to-date snapshot of the mempool. It is
	// updated periodically after N transactions OR after M  seconds, whichever
	// comes first. It's useful because it can be obtained without acquiring a
	// lock on the mempool.
	//
	// This field isn't reset with ResetPool. It requires an explicit call to
	// UpdateReadOnlyView.
	readOnlyUtxoView *UtxoView
	// Keep a list of all transactions in the mempool. This is useful for dumping
	// to the database periodically.
	readOnlyUniversalTransactionList []*MempoolTx
	readOnlyUniversalTransactionMap  map[BlockHash]*MempoolTx
	readOnlyOutpoints                map[UtxoKey]*MsgDeSoTxn
	// Every time the readOnlyUtxoView is updated, this is incremented. It can
	// be used by obtainers of the readOnlyUtxoView to wait until a particular
	// transaction has been run.
	//
	// This field isn't reset with ResetPool. It requires an explicit call to
	// UpdateReadOnlyView.
	readOnlyUtxoViewSequenceNumber int64
	// The total number of times we've called processTransaction. Used to
	// determine whether we should update the readOnlyUtxoView.
	//
	// This field isn't reset with ResetPool. It requires an explicit call to
	// UpdateReadOnlyView.
	totalProcessTransactionCalls int64

	// We pass a copy of the data dir flag to the tx pool so that we can instantiate
	// temp badger db instances and dump mempool txns to them.
	dataDir string
} 
type MiningSupplyIntervalStart struct {
	StartBlockHeight uint32
	BlockRewardNanos uint64
} 
type PurchaseSupplyIntervalStart struct {
	// How much each unit costs to purchase in Satoshis.
	SatoshisPerUnit uint64
	// The total supply cutoff at which this price applies.
	SupplyStartNanos uint64
} 
type NFTEntryResponse struct {
	OwnerPublicKeyBase58Check  string                `safeForLogging:"true"`
	ProfileEntryResponse       *ProfileEntryResponse `json:",omitempty"`
	PostEntryResponse          *PostEntryResponse    `json:",omitempty"`
	SerialNumber               uint64                `safeForLogging:"true"`
	IsForSale                  bool                  `safeForLogging:"true"`
	IsPending                  bool                  `safeForLogging:"true"`
	IsBuyNow                   bool                  `safeForLogging:"true"`
	BuyNowPriceNanos           uint64                `safeForLogging:"true"`
	MinBidAmountNanos          uint64                `safeForLogging:"true"`
	LastAcceptedBidAmountNanos uint64                `safeForLogging:"true"`

	HighestBidAmountNanos uint64 `safeForLogging:"true"`
	LowestBidAmountNanos  uint64 `safeForLogging:"true"`
	// These fields are only populated when the reader is the owner.
	LastOwnerPublicKeyBase58Check *string `json:",omitempty"`
	EncryptedUnlockableText       *string `json:",omitempty"`
} 
type NFTCollectionResponse struct {
	ProfileEntryResponse    *ProfileEntryResponse `json:",omitempty"`
	PostEntryResponse       *PostEntryResponse    `json:",omitempty"`
	HighestBidAmountNanos   uint64                `safeForLogging:"true"`
	LowestBidAmountNanos    uint64                `safeForLogging:"true"`
	HighestBuyNowPriceNanos *uint64               `safeForLogging:"true"`
	LowestBuyNowPriceNanos  *uint64               `safeForLogging:"true"`
	NumCopiesForSale        uint64                `safeForLogging:"true"`
	NumCopiesBuyNow         uint64                `safeForLogging:"true"`
	AvailableSerialNumbers  []uint64              `safeForLogging:"true"`
} 
type NFTBidEntryResponse struct {
	PublicKeyBase58Check string
	ProfileEntryResponse *ProfileEntryResponse `json:",omitempty"`
	PostHashHex          *string               `json:",omitempty"`
	// likely nil if included in a list of NFTBidEntryResponses for a single NFT
	PostEntryResponse *PostEntryResponse `json:",omitempty"`
	SerialNumber      uint64             `safeForLogging:"true"`
	BidAmountNanos    uint64             `safeForLogging:"true"`

	// What is the highest bid and the lowest bid on this serial number
	HighestBidAmountNanos *uint64 `json:",omitempty"`
	LowestBidAmountNanos  *uint64 `json:",omitempty"`

	// If we fetched the accepted bid history, include the accepted block height.
	AcceptedBlockHeight *uint32 `json:",omitempty"`

	// Current balance of this bidder.
	BidderBalanceNanos uint64
} 
type CreateNFTRequest struct {
	UpdaterPublicKeyBase58Check    string            `safeForLogging:"true"`
	NFTPostHashHex                 string            `safeForLogging:"true"`
	NumCopies                      int               `safeForLogging:"true"`
	NFTRoyaltyToCreatorBasisPoints int               `safeForLogging:"true"`
	NFTRoyaltyToCoinBasisPoints    int               `safeForLogging:"true"`
	HasUnlockable                  bool              `safeForLogging:"true"`
	IsForSale                      bool              `safeForLogging:"true"`
	MinBidAmountNanos              int               `safeForLogging:"true"`
	IsBuyNow                       bool              `safeForLogging:"true"`
	BuyNowPriceNanos               uint64            `safeForLogging:"true"`
	AdditionalDESORoyaltiesMap     map[string]uint64 `safeForLogging:"true"`
	AdditionalCoinRoyaltiesMap     map[string]uint64 `safeForLogging:"true"`

	MinFeeRateNanosPerKB uint64 `safeForLogging:"true"`

	// No need to specify ProfileEntryResponse in each TransactionFee
	TransactionFees []TransactionFee `safeForLogging:"true"`
} 
type CreateNFTResponse struct {
	NFTPostHashHex string `safeForLogging:"true"`

	TotalInputNanos   uint64
	ChangeAmountNanos uint64
	FeeNanos          uint64
	Transaction       MsgDeSoTxn
	TransactionHex    string
} 
type UpdateNFTRequest struct {
	UpdaterPublicKeyBase58Check string `safeForLogging:"true"`
	NFTPostHashHex              string `safeForLogging:"true"`
	SerialNumber                int    `safeForLogging:"true"`
	IsForSale                   bool   `safeForLogging:"true"`
	MinBidAmountNanos           int    `safeForLogging:"true"`
	IsBuyNow                    bool   `safeForLogging:"true"`
	BuyNowPriceNanos            uint64 `safeForLogging:"true"`

	MinFeeRateNanosPerKB uint64 `safeForLogging:"true"`

	// No need to specify ProfileEntryResponse in each TransactionFee
	TransactionFees []TransactionFee `safeForLogging:"true"`
} 
type UpdateNFTResponse struct {
	NFTPostHashHex string `safeForLogging:"true"`
	SerialNumber   int    `safeForLogging:"true"`

	TotalInputNanos   uint64
	ChangeAmountNanos uint64
	FeeNanos          uint64
	Transaction       MsgDeSoTxn
	TransactionHex    string
} 
type CreateNFTBidRequest struct {
	UpdaterPublicKeyBase58Check string `safeForLogging:"true"`
	NFTPostHashHex              string `safeForLogging:"true"`
	SerialNumber                int    `safeForLogging:"true"`
	BidAmountNanos              int    `safeForLogging:"true"`

	MinFeeRateNanosPerKB uint64 `safeForLogging:"true"`

	// No need to specify ProfileEntryResponse in each TransactionFee
	TransactionFees []TransactionFee `safeForLogging:"true"`
} 
type CreateNFTBidResponse struct {
	UpdaterPublicKeyBase58Check string `safeForLogging:"true"`
	NFTPostHashHex              string `safeForLogging:"true"`
	SerialNumber                int    `safeForLogging:"true"`
	BidAmountNanos              int    `safeForLogging:"true"`

	TotalInputNanos   uint64
	ChangeAmountNanos uint64
	FeeNanos          uint64
	Transaction       MsgDeSoTxn
	TransactionHex    string
} 
type AcceptNFTBidRequest struct {
	UpdaterPublicKeyBase58Check string `safeForLogging:"true"`
	NFTPostHashHex              string `safeForLogging:"true"`
	SerialNumber                int    `safeForLogging:"true"`
	BidderPublicKeyBase58Check  string `safeForLogging:"true"`
	BidAmountNanos              int    `safeForLogging:"true"`
	EncryptedUnlockableText     string `safeForLogging:"true"`

	MinFeeRateNanosPerKB uint64 `safeForLogging:"true"`

	// No need to specify ProfileEntryResponse in each TransactionFee
	TransactionFees []TransactionFee `safeForLogging:"true"`
} 
type AcceptNFTBidResponse struct {
	BidderPublicKeyBase58Check string `safeForLogging:"true"`
	NFTPostHashHex             string `safeForLogging:"true"`
	SerialNumber               int    `safeForLogging:"true"`
	BidAmountNanos             int    `safeForLogging:"true"`

	TotalInputNanos   uint64
	ChangeAmountNanos uint64
	FeeNanos          uint64
	Transaction       MsgDeSoTxn
	TransactionHex    string
} 
type GetNFTShowcaseRequest struct {
	ReaderPublicKeyBase58Check string `safeForLogging:"true"`
} 
type GetNFTShowcaseResponse struct {
	NFTCollections []*NFTCollectionResponse
} 
type GetNextNFTShowcaseResponse struct {
	NextNFTShowcaseTstamp uint64
} 
type GetNFTsForUserRequest struct {
	UserPublicKeyBase58Check   string `safeForLogging:"true"`
	ReaderPublicKeyBase58Check string `safeForLogging:"true"`
	IsForSale                  *bool  `safeForLogging:"true"`
	// Ignored if IsForSale is provided
	IsPending *bool `safeForLogging:"true"`
} 
type NFTEntryAndPostEntryResponse struct {
	PostEntryResponse *PostEntryResponse
	NFTEntryResponses []*NFTEntryResponse
} 
type GetNFTsForUserResponse struct {
	NFTsMap map[string]*NFTEntryAndPostEntryResponse
} 
type GetNFTBidsForUserRequest struct {
	UserPublicKeyBase58Check   string `safeForLogging:"true"`
	ReaderPublicKeyBase58Check string `safeForLogging:"true"`
} 
type GetNFTBidsForUserResponse struct {
	NFTBidEntries                              []*NFTBidEntryResponse
	PublicKeyBase58CheckToProfileEntryResponse map[string]*ProfileEntryResponse
	PostHashHexToPostEntryResponse             map[string]*PostEntryResponse
} 
type GetNFTBidsForNFTPostRequest struct {
	ReaderPublicKeyBase58Check string
	PostHashHex                string
} 
type GetNFTBidsForNFTPostResponse struct {
	PostEntryResponse *PostEntryResponse
	NFTEntryResponses []*NFTEntryResponse
	BidEntryResponses []*NFTBidEntryResponse
} 
type GetNFTCollectionSummaryRequest struct {
	PostHashHex                string
	ReaderPublicKeyBase58Check string
} 
type GetNFTCollectionSummaryResponse struct {
	NFTCollectionResponse          *NFTCollectionResponse
	SerialNumberToNFTEntryResponse map[uint64]*NFTEntryResponse
} 
type GetNFTEntriesForPostHashRequest struct {
	PostHashHex                string
	ReaderPublicKeyBase58Check string
} 
type GetNFTEntriesForPostHashResponse struct {
	NFTEntryResponses []*NFTEntryResponse
} 
type TransferNFTRequest struct {
	SenderPublicKeyBase58Check   string `safeForLogging:"true"`
	ReceiverPublicKeyBase58Check string `safeForLogging:"true"`
	NFTPostHashHex               string `safeForLogging:"true"`
	SerialNumber                 int    `safeForLogging:"true"`
	EncryptedUnlockableText      string `safeForLogging:"true"`

	MinFeeRateNanosPerKB uint64 `safeForLogging:"true"`

	// No need to specify ProfileEntryResponse in each TransactionFee
	TransactionFees []TransactionFee `safeForLogging:"true"`
} 
type TransferNFTResponse struct {
	SenderPublicKeyBase58Check   string `safeForLogging:"true"`
	ReceiverPublicKeyBase58Check string `safeForLogging:"true"`
	NFTPostHashHex               string `safeForLogging:"true"`
	SerialNumber                 int    `safeForLogging:"true"`

	TotalInputNanos   uint64
	ChangeAmountNanos uint64
	FeeNanos          uint64
	Transaction       MsgDeSoTxn
	TransactionHex    string
} 
type AcceptNFTTransferRequest struct {
	UpdaterPublicKeyBase58Check string `safeForLogging:"true"`
	NFTPostHashHex              string `safeForLogging:"true"`
	SerialNumber                int    `safeForLogging:"true"`

	MinFeeRateNanosPerKB uint64 `safeForLogging:"true"`

	// No need to specify ProfileEntryResponse in each TransactionFee
	TransactionFees []TransactionFee `safeForLogging:"true"`
} 
type AcceptNFTTransferResponse struct {
	UpdaterPublicKeyBase58Check string `safeForLogging:"true"`
	NFTPostHashHex              string `safeForLogging:"true"`
	SerialNumber                int    `safeForLogging:"true"`

	TotalInputNanos   uint64
	ChangeAmountNanos uint64
	FeeNanos          uint64
	Transaction       MsgDeSoTxn
	TransactionHex    string
} 
type BurnNFTRequest struct {
	UpdaterPublicKeyBase58Check string `safeForLogging:"true"`
	NFTPostHashHex              string `safeForLogging:"true"`
	SerialNumber                int    `safeForLogging:"true"`

	MinFeeRateNanosPerKB uint64 `safeForLogging:"true"`

	// No need to specify ProfileEntryResponse in each TransactionFee
	TransactionFees []TransactionFee `safeForLogging:"true"`
} 
type BurnNFTResponse struct {
	UpdaterPublicKeyBase58Check string `safeForLogging:"true"`
	NFTPostHashHex              string `safeForLogging:"true"`
	SerialNumber                int    `safeForLogging:"true"`

	TotalInputNanos   uint64
	ChangeAmountNanos uint64
	FeeNanos          uint64
	Transaction       MsgDeSoTxn
	TransactionHex    string
} 
type GetNFTsCreatedByPublicKeyRequest struct {
	// Either PublicKeyBase58Check or Username can be set by the client to specify
	// which user we're obtaining NFTs for
	// If both are specified, PublicKeyBase58Check will supercede
	PublicKeyBase58Check string `safeForLogging:"true"`
	Username             string `safeForLogging:"true"`

	ReaderPublicKeyBase58Check string `safeForLogging:"true"`
	// PostHashHex of the last NFT from the previous page
	LastPostHashHex string `safeForLogging:"true"`
	// Number of records to fetch
	NumToFetch uint64 `safeForLogging:"true"`
} 
type NFTDetails struct {
	NFTEntryResponses     []*NFTEntryResponse
	NFTCollectionResponse *NFTCollectionResponse
} 
type GetNFTsCreatedByPublicKeyResponse struct {
	NFTs            []NFTDetails `safeForLogging:"true"`
	LastPostHashHex string       `safeForLogging:"true"`
} 
type GetAcceptedBidHistoryResponse struct {
	AcceptedBidHistoryMap map[uint64][]*NFTBidEntryResponse
} 
type NodeControlRequest struct {
	// An address in <IP>:<Port> format.
	Address string `safeForLogging:"true"`

	// A comma-separated list of miner public keys to use.
	MinerPublicKeys string `safeForLogging:"true"`

	// The type of operation to perform on the node.
	OperationType string `safeForLogging:"true"`

	JWT            string
	AdminPublicKey string
} 
type NodeStatusResponse struct {
	// A summary of what the node is currently doing.
	State string `safeForLogging:"true"`

	// We generally track the latest header we have and the latest block we have
	// separately since headers-first synchronization can cause the latest header
	// to diverge slightly from the latest block.
	LatestHeaderHeight     uint32 `safeForLogging:"true"`
	LatestHeaderHash       string `safeForLogging:"true"`
	LatestHeaderTstampSecs uint32 `safeForLogging:"true"`

	LatestBlockHeight     uint32 `safeForLogging:"true"`
	LatestBlockHash       string `safeForLogging:"true"`
	LatestBlockTstampSecs uint32 `safeForLogging:"true"`
	LatestTxIndexHeight   uint32 `safeForLogging:"true"`

	// This is non-zero unless the main header chain is fully current. It can be
	// an estimate in cases where we don't know exactly what the tstamp of the
	// current main chain is.
	HeadersRemaining uint32 `safeForLogging:"true"`
	// This is non-zero unless the main header chain is fully current and all
	// the corresponding blocks have been downloaded.
	BlocksRemaining uint32 `safeForLogging:"true"`
} 
type PeerResponse struct {
	IP           string
	ProtocolPort uint16
	IsSyncPeer   bool
} 
type NodeControlResponse struct {
	// The current status the DeSo node is at in terms of syncing the DeSo
	// chain.
	DeSoStatus *NodeStatusResponse

	DeSoOutboundPeers    []*PeerResponse
	DeSoInboundPeers     []*PeerResponse
	DeSoUnconnectedPeers []*PeerResponse

	MinerPublicKeys []string
} 
type AdminGetMempoolStatsResponse struct {
	TransactionSummaryStats map[string]SummaryStats
} 
type Notifier struct {
	coreChain *Blockchain
	postgres  *Postgres

	// Shortcut to postgres.db
	db *pg.DB

	// Shortcut to coreChain.db
	badger *badger.DB
} 
type PKID [100]byte 
type PublicKey [100]byte 
type BlockHash [100]byte 
type Postgres struct {
	db *pg.DB
} 
type PGChain struct {
	tableName struct{} `pg:"pg_chains"`

	Name    string     `pg:",pk"`
	TipHash *BlockHash `pg:",type:bytea"`
} 
type PGBlock struct {
	tableName struct{} `pg:"pg_blocks"`

	// BlockNode and MsgDeSoHeader
	Hash       *BlockHash `pg:",pk,type:bytea"`
	ParentHash *BlockHash `pg:",type:bytea"`
	Height     uint64     `pg:",use_zero"`

	// BlockNode
	DifficultyTarget *BlockHash  `pg:",type:bytea"`
	CumWork          *BlockHash  `pg:",type:bytea"`
	Status           BlockStatus `pg:",use_zero"` // TODO: Refactor

	// MsgDeSoHeader
	TxMerkleRoot *BlockHash `pg:",type:bytea"`
	Version      uint32     `pg:",use_zero"`
	Timestamp    uint64     `pg:",use_zero"`
	Nonce        uint64     `pg:",use_zero"`
	ExtraNonce   uint64     `pg:",use_zero"`

	// Notifications
	Notified bool `pg:",use_zero"`
} 
type PGTransaction struct {
	tableName struct{} `pg:"pg_transactions"`

	Hash      *BlockHash `pg:",pk,type:bytea"`
	BlockHash *BlockHash `pg:",type:bytea"`
	Type      TxnType    `pg:",use_zero"`
	PublicKey []byte     `pg:",type:bytea"`
	ExtraData map[string][]byte
	R         *BlockHash `pg:",type:bytea"`
	S         *BlockHash `pg:",type:bytea"`

	// Relationships
	Outputs                     []*PGTransactionOutput         `pg:"rel:has-many,join_fk:output_hash"`
	MetadataBlockReward         *PGMetadataBlockReward         `pg:"rel:belongs-to,join_fk:transaction_hash"`
	MetadataBitcoinExchange     *PGMetadataBitcoinExchange     `pg:"rel:belongs-to,join_fk:transaction_hash"`
	MetadataPrivateMessage      *PGMetadataPrivateMessage      `pg:"rel:belongs-to,join_fk:transaction_hash"`
	MetadataSubmitPost          *PGMetadataSubmitPost          `pg:"rel:belongs-to,join_fk:transaction_hash"`
	MetadataUpdateExchangeRate  *PGMetadataUpdateExchangeRate  `pg:"rel:belongs-to,join_fk:transaction_hash"`
	MetadataUpdateProfile       *PGMetadataUpdateProfile       `pg:"rel:belongs-to,join_fk:transaction_hash"`
	MetadataFollow              *PGMetadataFollow              `pg:"rel:belongs-to,join_fk:transaction_hash"`
	MetadataLike                *PGMetadataLike                `pg:"rel:belongs-to,join_fk:transaction_hash"`
	MetadataCreatorCoin         *PGMetadataCreatorCoin         `pg:"rel:belongs-to,join_fk:transaction_hash"`
	MetadataCreatorCoinTransfer *PGMetadataCreatorCoinTransfer `pg:"rel:belongs-to,join_fk:transaction_hash"`
	MetadataSwapIdentity        *PGMetadataSwapIdentity        `pg:"rel:belongs-to,join_fk:transaction_hash"`
	MetadataCreateNFT           *PGMetadataCreateNFT           `pg:"rel:belongs-to,join_fk:transaction_hash"`
	MetadataUpdateNFT           *PGMetadataUpdateNFT           `pg:"rel:belongs-to,join_fk:transaction_hash"`
	MetadataAcceptNFTBid        *PGMetadataAcceptNFTBid        `pg:"rel:belongs-to,join_fk:transaction_hash"`
	MetadataNFTBid              *PGMetadataNFTBid              `pg:"rel:belongs-to,join_fk:transaction_hash"`
	MetadataNFTTransfer         *PGMetadataNFTTransfer         `pg:"rel:belongs-to,join_fk:transaction_hash"`
	MetadataAcceptNFTTransfer   *PGMetadataAcceptNFTTransfer   `pg:"rel:belongs-to,join_fk:transaction_hash"`
	MetadataBurnNFT             *PGMetadataBurnNFT             `pg:"rel:belongs-to,join_fk:transaction_hash"`
	MetadataDerivedKey          *PGMetadataDerivedKey          `pg:"rel:belongs-to,join_fk:transaction_hash"`
	MetadataDAOCoin             *PGMetadataDAOCoin             `pg:"rel:belongs-to,join_fk:transaction_hash"`
	MetadataDAOCoinTransfer     *PGMetadataDAOCoinTransfer     `pg:"rel:belongs-to,join_fk:transaction_hash"`
} 
type PGTransactionOutput struct {
	tableName struct{} `pg:"pg_transaction_outputs"`

	OutputHash  *BlockHash `pg:",pk"`
	OutputIndex uint32     `pg:",pk,use_zero"`
	OutputType  UtxoType   `pg:",use_zero"`
	Height      uint32     `pg:",use_zero"`
	PublicKey   []byte
	AmountNanos uint64 `pg:",use_zero"`
	Spent       bool   `pg:",use_zero"`
	InputHash   *BlockHash
	InputIndex  uint32 `pg:",pk,use_zero"`
} 
type PGMetadataBlockReward struct {
	tableName struct{} `pg:"pg_metadata_block_rewards"`

	TransactionHash *BlockHash `pg:",pk,type:bytea"`
	ExtraData       []byte     `pg:",type:bytea"`
} 
type PGMetadataBitcoinExchange struct {
	tableName struct{} `pg:"pg_metadata_bitcoin_exchanges"`

	TransactionHash   *BlockHash `pg:",pk,type:bytea"`
	BitcoinBlockHash  *BlockHash `pg:",type:bytea"`
	BitcoinMerkleRoot *BlockHash `pg:",type:bytea"`
	// Not storing BitcoinTransaction *wire.MsgTx
	// Not storing BitcoinMerkleProof []*merkletree.ProofPart
} 
type PGMetadataPrivateMessage struct {
	tableName struct{} `pg:"pg_metadata_private_messages"`

	TransactionHash    *BlockHash `pg:",pk,type:bytea"`
	RecipientPublicKey []byte     `pg:",type:bytea"`
	EncryptedText      []byte     `pg:",type:bytea"`
	TimestampNanos     uint64
} 
type PGMetadataSubmitPost struct {
	tableName struct{} `pg:"pg_metadata_submit_posts"`

	TransactionHash  *BlockHash `pg:",pk,type:bytea"`
	PostHashToModify *BlockHash `pg:",type:bytea"`
	ParentStakeID    *BlockHash `pg:",type:bytea"`
	Body             []byte     `pg:",type:bytea"`
	TimestampNanos   uint64
	IsHidden         bool `pg:",use_zero"`
} 
type PGMetadataUpdateExchangeRate struct {
	tableName struct{} `pg:"pg_metadata_update_exchange_rates"`

	TransactionHash    *BlockHash `pg:",pk,type:bytea"`
	USDCentsPerBitcoin uint64     `pg:",use_zero"`
} 
type PGMetadataUpdateProfile struct {
	tableName struct{} `pg:"pg_metadata_update_profiles"`

	TransactionHash       *BlockHash `pg:",pk,type:bytea"`
	ProfilePublicKey      []byte     `pg:",type:bytea"`
	NewUsername           []byte     `pg:",type:bytea"`
	NewDescription        []byte     `pg:",type:bytea"`
	NewProfilePic         []byte     `pg:",type:bytea"`
	NewCreatorBasisPoints uint64     `pg:",use_zero"`
} 
type PGMetadataFollow struct {
	tableName struct{} `pg:"pg_metadata_follows"`

	TransactionHash   *BlockHash `pg:",pk,type:bytea"`
	FollowedPublicKey []byte     `pg:",type:bytea"`
	IsUnfollow        bool       `pg:",use_zero"`
} 
type PGMetadataLike struct {
	tableName struct{} `pg:"pg_metadata_likes"`

	TransactionHash *BlockHash `pg:",pk,type:bytea"`
	LikedPostHash   *BlockHash `pg:",type:bytea"`
	IsUnlike        bool       `pg:",use_zero"`
} 
type PGMetadataCreatorCoin struct {
	tableName struct{} `pg:"pg_metadata_creator_coins"`

	TransactionHash             *BlockHash               `pg:",pk,type:bytea"`
	ProfilePublicKey            []byte                   `pg:",type:bytea"`
	OperationType               CreatorCoinOperationType `pg:",use_zero"`
	DeSoToSellNanos             uint64                   `pg:",use_zero"`
	CreatorCoinToSellNanos      uint64                   `pg:",use_zero"`
	DeSoToAddNanos              uint64                   `pg:",use_zero"`
	MinDeSoExpectedNanos        uint64                   `pg:",use_zero"`
	MinCreatorCoinExpectedNanos uint64                   `pg:",use_zero"`
} 
type PGMetadataCreatorCoinTransfer struct {
	tableName struct{} `pg:"pg_metadata_creator_coin_transfers"`

	TransactionHash            *BlockHash `pg:",pk,type:bytea"`
	ProfilePublicKey           []byte     `pg:",type:bytea"`
	CreatorCoinToTransferNanos uint64     `pg:",use_zero"`
	ReceiverPublicKey          []byte     `pg:",type:bytea"`
} 
type PGMetadataDAOCoin struct {
	tableName struct{} `pg:"pg_metadata_dao_coins"`

	TransactionHash           *BlockHash           `pg:",pk,type:bytea"`
	ProfilePublicKey          []byte               `pg:",type:bytea"`
	OperationType             DAOCoinOperationType `pg:",use_zero"`
	CoinsToMintNanos          string
	CoinsToBurnNanos          string
	TransferRestrictionStatus `pg:",use_zero"`
} 
type PGMetadataDAOCoinTransfer struct {
	tableName struct{} `pg:"pg_metadata_dao_coin_transfers"`

	TransactionHash        *BlockHash `pg:",pk,type:bytea"`
	ProfilePublicKey       []byte     `pg:",type:bytea"`
	DAOCoinToTransferNanos string     `pg:"dao_coin_to_transfer_nanos,use_zero"`
	ReceiverPublicKey      []byte     `pg:",type:bytea"`
} 
type PGMetadataSwapIdentity struct {
	tableName struct{} `pg:"pg_metadata_swap_identities"`

	TransactionHash *BlockHash `pg:",pk,type:bytea"`
	FromPublicKey   []byte     `pg:",type:bytea"`
	ToPublicKey     []byte     `pg:",type:bytea"`
} 
type PGMetadataCreateNFT struct {
	tableName struct{} `pg:"pg_metadata_create_nfts"`

	TransactionHash           *BlockHash `pg:",pk,type:bytea"`
	NFTPostHash               *BlockHash `pg:",type:bytea"`
	NumCopies                 uint64     `pg:",use_zero"`
	HasUnlockable             bool       `pg:",use_zero"`
	IsForSale                 bool       `pg:",use_zero"`
	MinBidAmountNanos         uint64     `pg:",use_zero"`
	CreatorRoyaltyBasisPoints uint64     `pg:",use_zero"`
	CoinRoyaltyBasisPoints    uint64     `pg:",use_zero"`
} 
type PGMetadataUpdateNFT struct {
	tableName struct{} `pg:"pg_metadata_update_nfts"`

	TransactionHash   *BlockHash `pg:",pk,type:bytea"`
	NFTPostHash       *BlockHash `pg:",type:bytea"`
	SerialNumber      uint64     `pg:",use_zero"`
	IsForSale         bool       `pg:",use_zero"`
	MinBidAmountNanos uint64     `pg:",use_zero"`
} 
type PGMetadataAcceptNFTBid struct {
	tableName struct{} `pg:"pg_metadata_accept_nft_bids"`

	TransactionHash *BlockHash            `pg:",pk,type:bytea"`
	NFTPostHash     *BlockHash            `pg:",type:bytea"`
	SerialNumber    uint64                `pg:",use_zero"`
	BidderPKID      *PKID                 `pg:",type:bytea"`
	BidAmountNanos  uint64                `pg:",use_zero"`
	UnlockableText  []byte                `pg:",type:bytea"`
	BidderInputs    []*PGMetadataBidInput `pg:"rel:has-many,join_fk:transaction_hash"`
} 
type PGMetadataBidInput struct {
	tableName struct{} `pg:"pg_metadata_bid_inputs"`

	TransactionHash *BlockHash `pg:",pk,type:bytea"`
	InputHash       *BlockHash `pg:",pk,type:bytea"`
	InputIndex      uint32     `pg:",pk,use_zero"`
} 
type PGMetadataNFTBid struct {
	tableName struct{} `pg:"pg_metadata_nft_bids"`

	TransactionHash *BlockHash `pg:",pk,type:bytea"`
	NFTPostHash     *BlockHash `pg:",type:bytea"`
	SerialNumber    uint64     `pg:",use_zero"`
	BidAmountNanos  uint64     `pg:",use_zero"`
} 
type PGMetadataNFTTransfer struct {
	tableName struct{} `pg:"pg_metadata_nft_transfer"`

	TransactionHash   *BlockHash `pg:",pk,type:bytea"`
	NFTPostHash       *BlockHash `pg:",pk,type:bytea"`
	SerialNumber      uint64     `pg:",use_zero"`
	ReceiverPublicKey []byte     `pg:",pk,type:bytea"`
	UnlockableText    []byte     `pg:",type:bytea"`
} 
type PGMetadataAcceptNFTTransfer struct {
	tableName struct{} `pg:"pg_metadata_accept_nft_transfer"`

	TransactionHash *BlockHash `pg:",pk,type:bytea"`
	NFTPostHash     *BlockHash `pg:",pk,type:bytea"`
	SerialNumber    uint64     `pg:",use_zero"`
} 
type PGMetadataBurnNFT struct {
	tableName struct{} `pg:"pg_metadata_burn_nft"`

	TransactionHash *BlockHash `pg:",pk,type:bytea"`
	NFTPostHash     *BlockHash `pg:",pk,type:bytea"`
	SerialNumber    uint64     `pg:",use_zero"`
} 
type PGMetadataDerivedKey struct {
	tableName struct{} `pg:"pg_metadata_derived_keys"`

	TransactionHash  *BlockHash                       `pg:",pk,type:bytea"`
	DerivedPublicKey PublicKey                        `pg:",type:bytea"`
	ExpirationBlock  uint64                           `pg:",use_zero"`
	OperationType    AuthorizeDerivedKeyOperationType `pg:",use_zero"`
	AccessSignature  []byte                           `pg:",type:bytea"`
} 
type PGNotification struct {
	tableName struct{} `pg:"pg_notifications"`

	TransactionHash *BlockHash       `pg:",pk,type:bytea"`
	Mined           bool             `pg:",use_zero"`
	ToUser          []byte           `pg:",type:bytea"`
	FromUser        []byte           `pg:",type:bytea"`
	OtherUser       []byte           `pg:",type:bytea"`
	Type            NotificationType `pg:",use_zero"`
	Amount          uint64           `pg:",use_zero"`
	PostHash        *BlockHash       `pg:",type:bytea"`
	Timestamp       uint64           `pg:",use_zero"`
} 
type PGProfile struct {
	tableName struct{} `pg:"pg_profiles"`

	PKID               *PKID      `pg:",pk,type:bytea"`
	PublicKey          *PublicKey `pg:",type:bytea"`
	Username           string
	Description        string
	ProfilePic         []byte
	CreatorBasisPoints uint64
	DeSoLockedNanos    uint64
	NumberOfHolders    uint64
	// FIXME: Postgres will break when values exceed uint64
	// We don't use Postgres right now so going to plow ahead and set this as-is
	// to fix compile errors. CoinsInCirculationNanos will never exceed uint64
	CoinsInCirculationNanos          uint64
	CoinWatermarkNanos               uint64
	MintingDisabled                  bool
	DAOCoinNumberOfHolders           uint64                    `pg:"dao_coin_number_of_holders"`
	DAOCoinCoinsInCirculationNanos   string                    `pg:"dao_coin_coins_in_circulation_nanos"`
	DAOCoinMintingDisabled           bool                      `pg:"dao_coin_minting_disabled"`
	DAOCoinTransferRestrictionStatus TransferRestrictionStatus `pg:"dao_coin_transfer_restriction_status"`
} 
type PGPost struct {
	tableName struct{} `pg:"pg_posts"`

	PostHash                                    *BlockHash `pg:",pk,type:bytea"`
	PosterPublicKey                             []byte
	ParentPostHash                              *BlockHash `pg:",type:bytea"`
	Body                                        string
	RepostedPostHash                            *BlockHash        `pg:",type:bytea"`
	QuotedRepost                                bool              `pg:",use_zero"`
	Timestamp                                   uint64            `pg:",use_zero"`
	Hidden                                      bool              `pg:",use_zero"`
	LikeCount                                   uint64            `pg:",use_zero"`
	RepostCount                                 uint64            `pg:",use_zero"`
	QuoteRepostCount                            uint64            `pg:",use_zero"`
	DiamondCount                                uint64            `pg:",use_zero"`
	CommentCount                                uint64            `pg:",use_zero"`
	Pinned                                      bool              `pg:",use_zero"`
	NFT                                         bool              `pg:",use_zero"`
	NumNFTCopies                                uint64            `pg:",use_zero"`
	NumNFTCopiesForSale                         uint64            `pg:",use_zero"`
	NumNFTCopiesBurned                          uint64            `pg:",use_zero"`
	Unlockable                                  bool              `pg:",use_zero"`
	CreatorRoyaltyBasisPoints                   uint64            `pg:",use_zero"`
	CoinRoyaltyBasisPoints                      uint64            `pg:",use_zero"`
	AdditionalNFTRoyaltiesToCoinsBasisPoints    map[string]uint64 `pg:"additional_nft_royalties_to_coins_basis_points"`
	AdditionalNFTRoyaltiesToCreatorsBasisPoints map[string]uint64 `pg:"additional_nft_royalties_to_creators_basis_points"`
	ExtraData                                   map[string][]byte
} 
type PGLike struct {
	tableName struct{} `pg:"pg_likes"`

	LikerPublicKey []byte     `pg:",pk,type:bytea"`
	LikedPostHash  *BlockHash `pg:",pk,type:bytea"`
} 
type PGFollow struct {
	tableName struct{} `pg:"pg_follows"`

	FollowerPKID *PKID `pg:",pk,type:bytea"`
	FollowedPKID *PKID `pg:",pk,type:bytea"`
} 
type PGDiamond struct {
	tableName struct{} `pg:"pg_diamonds"`

	SenderPKID      *PKID      `pg:",pk,type:bytea"`
	ReceiverPKID    *PKID      `pg:",pk,type:bytea"`
	DiamondPostHash *BlockHash `pg:",pk,type:bytea"`
	DiamondLevel    uint8
} 
type PGMessage struct {
	tableName struct{} `pg:"pg_messages"`

	MessageHash        *BlockHash `pg:",pk,type:bytea"`
	SenderPublicKey    []byte
	RecipientPublicKey []byte
	EncryptedText      []byte
	TimestampNanos     uint64
	// TODO: Version

	// Used to track deletions in the UtxoView
	isDeleted bool
} 
type PGMessagingGroup struct {
	tableName struct{} `pg:"pg_messaging_group"`

	GroupOwnerPublicKey   *PublicKey    `pg:",type:bytea"`
	MessagingPublicKey    *PublicKey    `pg:",type:bytea"`
	MessagingGroupKeyName *GroupKeyName `pg:",type:bytea"`
	MessagingGroupMembers []byte        `pg:",type:bytea"`
} 
type PGCreatorCoinBalance struct {
	tableName struct{} `pg:"pg_creator_coin_balances"`

	HolderPKID   *PKID `pg:",pk,type:bytea"`
	CreatorPKID  *PKID `pg:",pk,type:bytea"`
	BalanceNanos uint64
	HasPurchased bool
} 
type PGDAOCoinBalance struct {
	tableName struct{} `pg:"pg_dao_coin_balances"`

	HolderPKID   *PKID `pg:",pk,type:bytea"`
	CreatorPKID  *PKID `pg:",pk,type:bytea"`
	BalanceNanos string
	HasPurchased bool
} 
type PGBalance struct {
	tableName struct{} `pg:"pg_balances"`

	PublicKey    *PublicKey `pg:",pk,type:bytea"`
	BalanceNanos uint64     `pg:",use_zero"`
} 
type PGGlobalParams struct {
	tableName struct{} `pg:"pg_global_params"`

	ID uint64

	USDCentsPerBitcoin      uint64 `pg:",use_zero"`
	CreateProfileFeeNanos   uint64 `pg:",use_zero"`
	CreateNFTFeeNanos       uint64 `pg:",use_zero"`
	MaxCopiesPerNFT         uint64 `pg:",use_zero"`
	MinNetworkFeeNanosPerKB uint64 `pg:",use_zero"`
} 
type PGRepost struct {
	tableName struct{} `pg:"pg_reposts"`

	ReposterPublickey *PublicKey `pg:",pk,type:bytea"`
	RepostedPostHash  *BlockHash `pg:",pk,type:bytea"`
	RepostPostHash    *BlockHash `pg:",type:bytea"`

	// Whether or not this entry is deleted in the view.
	isDeleted bool
} 
type PGForbiddenKey struct {
	tableName struct{} `pg:"pg_forbidden_keys"`

	PublicKey *PublicKey `pg:",pk,type:bytea"`
} 
type PGNFT struct {
	tableName struct{} `pg:"pg_nfts"`

	NFTPostHash  *BlockHash `pg:",pk,type:bytea"`
	SerialNumber uint64     `pg:",pk"`

	// This is needed to decrypt unlockable text.
	LastOwnerPKID              *PKID  `pg:",type:bytea"`
	OwnerPKID                  *PKID  `pg:",type:bytea"`
	ForSale                    bool   `pg:",use_zero"`
	MinBidAmountNanos          uint64 `pg:",use_zero"`
	UnlockableText             string
	LastAcceptedBidAmountNanos uint64 `pg:",use_zero"`
	IsPending                  bool   `pg:",use_zero"`
	IsBuyNow                   bool   `pg:",use_zero"`
	BuyNowPriceNanos           uint64 `pg:",use_zero"`
} 
type PGNFTBid struct {
	tableName struct{} `pg:"pg_nft_bids"`

	BidderPKID          *PKID      `pg:",pk,type:bytea"`
	NFTPostHash         *BlockHash `pg:",pk,type:bytea"`
	SerialNumber        uint64     `pg:",pk,use_zero"`
	BidAmountNanos      uint64     `pg:",use_zero"`
	Accepted            bool       `pg:",use_zero"`
	AcceptedBlockHeight *uint32    `pg:",use_zero"`
} 
type PGDerivedKey struct {
	tableName struct{} `pg:"pg_derived_keys"`

	OwnerPublicKey   PublicKey                        `pg:",pk,type:bytea"`
	DerivedPublicKey PublicKey                        `pg:",pk,type:bytea"`
	ExpirationBlock  uint64                           `pg:",use_zero"`
	OperationType    AuthorizeDerivedKeyOperationType `pg:",use_zero"`
} 
type NotificationType uint8
 
type RichListEntry struct {
	KeyBytes     []byte
	BalanceNanos uint64
} 
type RichListEntryResponse struct {
	PublicKeyBase58Check string
	BalanceNanos         uint64
	BalanceDESO          float64
	Percentage           float64
	Value                float64
} 
type RuleError string 
type SendPhoneNumberVerificationTextRequest struct {
	PublicKeyBase58Check string `safeForLogging:"true"`
	PhoneNumber          string
	JWT                  string
} 
type SendPhoneNumberVerificationTextResponse struct {
} 
type SubmitPhoneNumberVerificationCodeRequest struct {
	JWT                  string
	PublicKeyBase58Check string
	PhoneNumber          string
	VerificationCode     string
} 
type SubmitPhoneNumberVerificationCodeResponse struct {
	TxnHashHex string
} 
type ResendVerifyEmailRequest struct {
	PublicKey string
	JWT       string
} 
type VerifyEmailRequest struct {
	PublicKey string
	EmailHash string
} 
type JumioInitRequest struct {
	CustomerInternalReference string `json:"customerInternalReference"`
	UserReference             string `json:"userReference"`
	SuccessURL                string `json:"successUrl"`
	ErrorURL                  string `json:"errorUrl"`
} 
type JumioInitResponse struct {
	RedirectURL          string `json:"redirectUrl"`
	TransactionReference string `json:"transactionReference"`
} 
type JumioBeginRequest struct {
	PublicKey          string
	ReferralHashBase58 string
	SuccessURL         string
	ErrorURL           string
	JWT                string
} 
type JumioBeginResponse struct {
	URL string
} 
type JumioFlowFinishedRequest struct {
	PublicKey              string
	JumioInternalReference string
	JWT                    string
} 
type JumioIdentityVerification struct {
	Similarity string `json:"similarity"`
	Validity   bool   `json:"validity"`
	Reason     string `json:"reason"`
} 
type JumioRejectReason struct {
	RejectReasonCode        string      `json:"rejectReasonCode"`
	RejectReasonDescription string      `json:"rejectReasonDescription"`
	RejectReasonDetails     interface{} `json:"rejectReasonDetails"`
} 
type GetJumioStatusForPublicKeyRequest struct {
	JWT                  string
	PublicKeyBase58Check string
} 
type GetJumioStatusForPublicKeyResponse struct {
	JumioFinishedTime uint64
	JumioReturned     bool
	JumioVerified     bool

	BalanceNanos *uint64
} 
type ServerMessage struct {
	Peer      *Peer
	Msg       DeSoMessage
	ReplyChan chan *ServerReply
} 
type GetDataRequestInfo struct {
	PeerWhoSentInv *Peer
	TimeRequested  time.Time
} 
type ServerReply struct {
} 
type Server struct {
	cmgr          *ConnectionManager
	blockchain    *Blockchain
	mempool       *DeSoMempool
	miner         *DeSoMiner
	blockProducer *DeSoBlockProducer
	eventManager  *EventManager

	// All messages received from peers get sent from the ConnectionManager to the
	// Server through this channel.
	//
	// Generally, the
	// ConnectionManager is responsible for managing the connections to all the peers,
	// but when it receives a message from one of them, it forwards it to the Server
	// on this channel to actually process (acting as a router in that way).
	//
	// In addition to messages from peers, the ConnectionManager will also send control
	// messages to notify the Server e.g. when a Peer connects or disconnects so that
	// the Server can take action appropriately.
	incomingMessages chan *ServerMessage
	// inventoryBeingProcessed keeps track of the inventory (hashes of blocks and
	// transactions) that we've recently processed from peers. It is useful for
	// avoiding situations in which we re-fetch the same data from many peers.
	// For example, if we get the same Block inv message from multiple peers,
	// adding it to this map and checking this map before replying will make it
	// so that we only send a reply to the first peer that sent us the inv, which
	// is more efficient.
	inventoryBeingProcessed lru.Cache
	// hasRequestedSync indicates whether we've bootstrapped our mempool
	// by requesting all mempool transactions from a
	// peer. It's initially false
	// when the server boots up but gets set to true after we make a Mempool
	// request once we're fully synced.
	// The waitGroup is used to manage the cleanup of the Server.
	waitGroup deadlock.WaitGroup

	// During initial block download, we request headers and blocks from a single
	// peer. Note: These fields should only be accessed from the messageHandler thread.
	//
	// TODO: This could be much faster if we were to download blocks in parallel
	// rather than from a single peer but it won't be a problem until later, at which
	// point we can make the optimization.
	SyncPeer *Peer
	// How long we wait on a transaction we're fetching before giving
	// up on it. Note this doesn't apply to blocks because they have their own
	// process for retrying that differs from transactions, which are
	// more best-effort than blocks.
	requestTimeoutSeconds uint32

	// dataLock protects requestedTxns and requestedBlocks
	dataLock deadlock.Mutex

	// requestedTransactions contains hashes of transactions for which we have
	// requested data but have not yet received a response.
	requestedTransactionsMap map[BlockHash]*GetDataRequestInfo

	// addrsToBroadcast is a list of all the addresses we've received from valid addr
	// messages that we intend to broadcast to our peers. It is organized as:
	// <recipient address> -> <list of addresses we received from that recipient>.
	//
	// It is organized in this way so that we can limit the number of addresses we
	// are distributing for a single peer to avoid a DOS attack.
	addrsToBroadcastLock deadlock.RWMutex
	addrsToBroadcastt    map[string][]*SingleAddr

	// When set to true, we disable the ConnectionManager
	disableNetworking bool

	// When set to true, transactions created on this node will be ignored.
	readOnlyMode                 bool
	ignoreInboundPeerInvMessages bool

	// Becomes true after the node has processed its first transaction bundle from
	// any peer. This is useful in a deployment setting because it makes it so that
	// a health check can wait until this value becomes true.
	hasProcessedFirstTransactionBundle bool

	statsdClient *statsd.Client

	Notifier *Notifier
} 
type SetUSDCentsToDeSoExchangeRateRequest struct {
	USDCentsPerDeSo uint64
	AdminPublicKey  string
} 
type SetUSDCentsToDeSoExchangeRateResponse struct {
	USDCentsPerDeSo uint64
} 
type GetUSDCentsToDeSoExchangeRateResponse struct {
	USDCentsPerDeSo uint64
} 
type SetBuyDeSoFeeBasisPointsRequest struct {
	BuyDeSoFeeBasisPoints uint64
	AdminPublicKey        string
} 
type SetBuyDeSoFeeBasisPointsResponse struct {
	BuyDeSoFeeBasisPoints uint64
} 
type GetBuyDeSoFeeBasisPointsResponse struct {
	BuyDeSoFeeBasisPoints uint64
} 
type TXIndex struct {
	// TXIndexLock protects the transaction index.
	TXIndexLock deadlock.RWMutex

	// The txindex has it s own separate Blockchain object. This allows us to
	// capture more metadata when collecting transactions without interfering
	// with the goings-on of the main chain.
	TXIndexChain *Blockchain

	// Core objects from Server
	CoreChain *Blockchain

	// Core params object
	Params *DeSoParams

	// Update wait group
	updateWaitGroup sync.WaitGroup

	// Shutdown channel
	stopUpdateChannel chan struct{}
} 
type TestMeta struct {
	t                      *testing.T
	chain                  *Blockchain
	db                     *badger.DB
	params                 *DeSoParams
	mempool                *DeSoMempool
	miner                  *DeSoMiner
	txnOps                 [][]*UtxoOperation
	txns                   []*MsgDeSoTxn
	expectedSenderBalances []uint64
	savedHeight            uint32
} 
type TransactionEvent struct {
	Txn     *MsgDeSoTxn
	TxnHash *BlockHash

	// Optional
	UtxoView *UtxoView
	UtxoOps  []*UtxoOperation
} 
type BlockEvent struct {
	Block *MsgDeSoBlock

	// Optional
	UtxoView *UtxoView
	UtxoOps  [][]*UtxoOperation
} 
type EventManager struct {
	transactionConnectedHandlers []TransactionEventFunc
	blockConnectedHandlers       []BlockEventFunc
	blockDisconnectedHandlers    []BlockEventFunc
	blockAcceptedHandlers        []BlockEventFunc
} 
type TransactionEventFunc func(event *TransactionEvent) 
type BlockEventFunc func(event *BlockEvent) 
type TransactionFee struct {
	// PublicKeyBase58Check is the public key of the user who receives the fee.
	PublicKeyBase58Check string
	// ProfileEntryResponse is only non-nil when TransactionFees are retrieved through admin endpoints.
	// The ProfileEntryResponse is only used to display usernames and avatars in the admin dashboard and thus is
	// excluded in other places to reduce payload sizes and improve performance.
	ProfileEntryResponse *ProfileEntryResponse
	// AmountNanos is the amount PublicKeyBase58Check receives when this fee is incurred.
	AmountNanos uint64
} 
type AdminSetTransactionFeeForTransactionTypeRequest struct {
	// TransactionType is the type of transaction for which we are setting the fees.
	TransactionType lib.TxnString
	// NewTransactionFees is a slice of TransactionFee structs that tells us who should receive a fee and how much
	// when a transaction of TransactionType is performed.
	NewTransactionFees []TransactionFee
} 
type AdminSetTransactionFeeForTransactionTypeResponse struct {
	// TransactionFeeMap is the current state of Transaction fees on this node after the fees defined in
	// AdminSetTransactionFeeForTransactionTypeRequest have been set.
	TransactionFeeMap map[string][]TransactionFee
} 
type AdminSetAllTransactionFeesRequest struct {
	// NewTransactionFees is a slice of TransactionFees that should be applied to all transaction types.
	// This overwrites all transaction types.
	NewTransactionFees []TransactionFee
} 
type AdminSetAllTransactionFeesResponse struct {
	// TransactionFeeMap is the current state of Transaction fees on this node after the fees defined in
	// AdminSetAllTransactionFeesRequest have been set.
	TransactionFeeMap map[string][]TransactionFee
} 
type AdminGetTransactionFeeMapResponse struct {
	// TransactionFeeMap is the current state of Transaction fees on this node.
	TransactionFeeMap map[string][]TransactionFee
} 
type AdminAddExemptPublicKey struct {
	// PublicKeyBase58Check is the public key for which we are adding or removing an exemption from node fees.
	PublicKeyBase58Check string
	// IsRemoval is a boolean that when true means we should remove the exemption from a public key, when false means we
	// should add an exemption.
	IsRemoval bool
} 
type AdminGetExemptPublicKeysResponse struct {
	// ExemptPublicKeyMap is a map of PublicKeyBase58Check to ProfileEntryResponse. These public keys do not have to pay
	// node fees.
	ExemptPublicKeyMap map[string]*ProfileEntryResponse
} 
type TransactionInfo struct {
	TotalInputNanos          uint64
	SpendAmountNanos         uint64
	ChangeAmountNanos        uint64
	FeeNanos                 uint64
	TransactionIDBase58Check string

	// These are Base58Check encoded
	RecipientPublicKeys   []string
	RecipientAmountsNanos []uint64

	TransactionHex string

	// TODO: Not including the transaction because it causes encoding to
	// fail due to the presence of an interface for TxnMeta.
	//Transaction    MsgDeSoTxn

	// Unix timestamp (seconds since epoch).
	TimeAdded int64
} 
type MessageEntryResponse struct {
	// SenderPublicKeyBase58Check is the main public key of the sender in base58check.
	SenderPublicKeyBase58Check    string

	// RecipientPublicKeyBase58Check is the main public key of the recipient in base58check.
	RecipientPublicKeyBase58Check string

	// EncryptedText is the encrypted message in hex format.
	EncryptedText string
	// TstampNanos is the message's timestamp.
	TstampNanos   uint64

	// Whether or not the user is the sender of the message.
	IsSender bool

	// Indicate if message was encrypted using shared secret
	V2 bool // Deprecated

	// Indicate message version
	Version uint32

	// ---------------------------------------------------------
	// DeSo V3 Messages Fields
	// ---------------------------------------------------------

	// SenderMessagingPublicKey is the sender's messaging public key that was used
	// to encrypt the corresponding message.
	SenderMessagingPublicKey string

	// SenderMessagingGroupKeyName is the sender's group key name of SenderMessagingPublicKey
	SenderMessagingGroupKeyName string

	// RecipientMessagingPublicKey is the recipient's messaging public key that was
	// used to encrypt the corresponding message.
	RecipientMessagingPublicKey string

	// RecipientMessagingGroupKeyName is the recipient's group key name of RecipientMessagingPublicKey
	RecipientMessagingGroupKeyName string
} 
type MessageContactResponse struct {
	// PublicKeyBase58Check is the public key in base58check format of the message contact.
	PublicKeyBase58Check string

	// Messages is the list of messages within this contact.
	Messages             []*MessageEntryResponse

	// ProfileEntryResponse is the profile entry corresponding to the contact.
	ProfileEntryResponse *ProfileEntryResponse

	// The number of messages this user has read from this contact. This is
	// used to show a notification badge for unread messages.
	NumMessagesRead int64
} 
type MessagingGroupEntryResponse struct {
	// GroupOwnerPublicKeyBase58Check is the main public key of the group owner, or, equivalently, the public key that
	// registered the group.
	GroupOwnerPublicKeyBase58Check string

	// MessagingPublicKeyBase58Check is the group messaging public key in base58check.
	MessagingPublicKeyBase58Check string

	// MessagingGroupKeyName is the name of the group messaging key.
	MessagingGroupKeyName string

	// MessagingGroupMembers is the list of the members in the group chat.
	MessagingGroupMembers []*MessagingGroupMemberResponse

	// EncryptedKey is the hex string of the encrypted private corresponding with the MessagingPublicKeyBase58Check.
	EncryptedKey string
} 
type MessagingGroupMemberResponse struct {
	// GroupMemberPublicKeyBase58Check is the main public key of the group member.
	GroupMemberPublicKeyBase58Check string

	// GroupMemberKeyName is the key name of the member that we encrypt the group messaging public key to. The group
	// messaging public key should not be confused with the GroupMemberPublicKeyBase58Check, the former is the public
	// key of the whole group, while the latter is the public key of the group member.
	GroupMemberKeyName string

	// EncryptedKey is the encrypted private key corresponding to the group messaging public key that's encrypted
	// to the member's registered messaging key labeled with GroupMemberKeyName.
	EncryptedKey string
} 
type User struct {
	// The public key for the user is computed from the seed using the exact
	// parameters used to generate the BTC deposit address below. Because
	// of this, the DeSo private and public key pair is also the key
	// pair corresponding to the BTC address above. We store this same
	// key in base58 format above for convenience in communicating with
	// the FE.
	PublicKeyBase58Check string

	ProfileEntryResponse *ProfileEntryResponse

	Utxos               []*UTXOEntryResponse
	BalanceNanos        uint64
	UnminedBalanceNanos uint64

	PublicKeysBase58CheckFollowedByUser []string

	UsersYouHODL         []*BalanceEntryResponse
	UsersWhoHODLYouCount int

	// HasPhoneNumber is a computed boolean so we can avoid returning the phone number in the
	// API response, since phone numbers are sensitive PII.
	HasPhoneNumber   bool
	CanCreateProfile bool
	BlockedPubKeys   map[string]struct{}
	HasEmail         bool
	EmailVerified    bool

	// JumioStartTime = Time user requested to initiate Jumio flow
	JumioStartTime uint64
	// JumioFinishedTime = Time user completed flow in Jumio
	JumioFinishedTime uint64
	// JumioVerified = user was verified from Jumio flow
	JumioVerified bool
	// JumioReturned = jumio webhook called
	JumioReturned bool

	// Is this user an admin
	IsAdmin bool
	// Is th user a super admin
	IsSuperAdmin bool

	// Is this user blacklisted/graylisted
	IsBlacklisted bool
	IsGraylisted  bool

	// Where is the user in the tutorial flow
	TutorialStatus TutorialStatus

	// Username of creator purchased during onboarding flow - used in case a user changes devices in the middle of the flow.
	CreatorPurchasedInTutorialUsername *string `json:",omitempty"`

	// Amount of creator coins purchased in the tutorial
	CreatorCoinsPurchasedInTutorial uint64

	// Does this user need to complete the tutorial
	MustCompleteTutorial bool
} 
type BalanceEntryResponse struct {
	// The public keys are provided for the frontend
	HODLerPublicKeyBase58Check string
	// The public keys are provided for the frontend
	CreatorPublicKeyBase58Check string

	// Has the hodler purchased this creator's coin
	HasPurchased bool

	// How much this HODLer owns of a particular creator coin.
	BalanceNanos uint64

	// For simplicity, we create a new field for the uint256 balance for DAO coins
	BalanceNanosUint256 uint256.Int

	// The net effect of transactions in the mempool on a given BalanceEntry's BalanceNanos.
	// This is used by the frontend to convey info about mining.
	NetBalanceInMempool int64

	ProfileEntryResponse *ProfileEntryResponse `json:",omitempty"`
} 
type UploadImageResponse struct {
	// Location of the image after upload
	ImageURL string
} 
type GetFullTikTokURLRequest struct {
	TikTokShortVideoID string
} 
type GetFullTikTokURLResponse struct {
	FullTikTokURL string
} 
type CFVideoDetailsResponse struct {
	Result   map[string]interface{} `json:"result"`
	Success  bool                   `json:"success"`
	Errors   []interface{}          `json:"errors"`
	Messages []interface{}          `json:"messages"`
} 
type GetVideoStatusResponse struct {
	ReadyToStream bool
	Duration float64
	Dimensions    map[string]interface{}
} 
type UtxoEntry struct {
	AmountNanos uint64
	PublicKey   []byte
	BlockHeight uint32
	UtxoType    UtxoType

	// The fields below aren't serialized or hashed. They are only kept
	// around for in-memory bookkeeping purposes.

	// Whether or not the UTXO is spent. This is not used by the database,
	// (in fact it's not even stored in the db) it's used
	// only by the in-memory data structure. The database is simple: A UTXO
	// is unspent if and only if it exists in the db. However, for the view,
	// a UTXO is unspent if it (exists in memory and is unspent) OR (it does not
	// exist in memory at all but does exist in the database).
	//
	// Note that we are relying on the code that serializes the entry to the
	// db to ignore private fields, which is why this variable is lowerCamelCase
	// rather than UpperCamelCase. We are also relying on it defaulting to
	// false when newly-read from the database.
	isSpent bool

	// A back-reference to the utxo key associated with this entry.
	UtxoKey *UtxoKey
} 
type UtxoOperation struct {
	Type OperationType

	// Only set for OperationTypeSpendUtxo
	//
	// When we SPEND a UTXO entry we delete it from the utxo set but we still
	// store its info in case we want to reverse
	// it in the future. This information is not needed for ADD since
	// reversing an ADD just means deleting an entry from the end of our list.
	//
	// SPEND works by swapping the UTXO we want to spend with the UTXO at
	// the end of the list and then deleting from the end of the list. Obviously
	// this is more efficient than deleting the element in-place and then shifting
	// over everything after it. In order to be able to undo this operation,
	// however, we need to store the original index of the item we are
	// spending/deleting. Reversing the operation then amounts to adding a utxo entry
	// at the end of the list and swapping with this index. Given this, the entry
	// we store here has its position set to the position it was at right before the
	// SPEND operation was performed.
	Entry *UtxoEntry

	// Only set for OperationTypeSpendUtxo
	//
	// Store the UtxoKey as well. This isn't necessary but it helps
	// with error-checking during a roll-back so we just keep it.
	//
	// TODO: We can probably delete this at some point and save some space. UTXOs
	// are probably our biggest disk hog so getting rid of this should materially
	// improve disk usage.
	Key *UtxoKey

	// Used to revert BitcoinExchange transaction.
	PrevNanosPurchased uint64
	// Used to revert UpdateBitcoinUSDExchangeRate transaction.
	PrevUSDCentsPerBitcoin uint64

	// Save the previous post entry when making an update to a post.
	PrevPostEntry            *PostEntry
	PrevParentPostEntry      *PostEntry
	PrevGrandparentPostEntry *PostEntry
	PrevRepostedPostEntry    *PostEntry

	// Save the previous profile entry when making an update.
	PrevProfileEntry *ProfileEntry

	// Save the previous like entry and like count when making an update.
	PrevLikeEntry *LikeEntry
	PrevLikeCount uint64

	// For disconnecting diamonds.
	PrevDiamondEntry *DiamondEntry

	// For disconnecting NFTs.
	PrevNFTEntry              *NFTEntry
	PrevNFTBidEntry           *NFTBidEntry
	DeletedNFTBidEntries      []*NFTBidEntry
	NFTPaymentUtxoKeys        []*UtxoKey
	NFTSpentUtxoEntries       []*UtxoEntry
	PrevAcceptedNFTBidEntries *[]*NFTBidEntry

	// For disconnecting AuthorizeDerivedKey transactions.
	PrevDerivedKeyEntry *DerivedKeyEntry

	// For disconnecting MessagingGroupKey transactions.
	PrevMessagingKeyEntry *MessagingGroupEntry

	// Save the previous repost entry and repost count when making an update.
	PrevRepostEntry *RepostEntry
	PrevRepostCount uint64

	// Save the state of a creator coin prior to updating it due to a
	// buy/sell/add transaction.
	PrevCoinEntry *CoinEntry

	// Save the state of coin entries associated with a PKID prior to updating
	// it due to an additional coin royalty when an NFT is sold.
	PrevCoinRoyaltyCoinEntries map[PKID]CoinEntry

	// Save the creator coin balance of both the transactor and the creator.
	// We modify the transactor's balances when they buys/sell a creator coin
	// and we modify the creator's balance when we pay them a founder reward.
	PrevTransactorBalanceEntry *BalanceEntry
	PrevCreatorBalanceEntry    *BalanceEntry
	// We use this to revert founder's reward UTXOs created by creator coin buys.
	FounderRewardUtxoKey *UtxoKey

	// Save balance entries for the sender and receiver when creator coins are transferred.
	PrevSenderBalanceEntry   *BalanceEntry
	PrevReceiverBalanceEntry *BalanceEntry

	// Save the global params when making an update.
	PrevGlobalParamsEntry    *GlobalParamsEntry
	PrevForbiddenPubKeyEntry *ForbiddenPubKeyEntry

	// This value is used by Rosetta to adjust for a bug whereby a ParamUpdater
	// CoinEntry could get clobbered if updating a profile on someone else's
	// behalf. This is super confusing.
	ClobberedProfileBugDESOLockedNanos uint64

	// This value is used by Rosetta to return the amount of DESO that was added
	// or removed from a profile during a CreatorCoin transaction. It's needed
	// in order to avoid having to reconnect all transactions.
	CreatorCoinDESOLockedNanosDiff int64

	// This value is used by Rosetta to create a proper input/output when we
	// encounter a SwapIdentity txn. This makes it so that we don't have to
	// reconnect all txns in order to get these values.
	SwapIdentityFromDESOLockedNanos uint64
	SwapIdentityToDESOLockedNanos   uint64

	// These values are used by Rosetta in order to create input and output
	// operations. They make it so that we don't have to reconnect all txns
	// in order to get these values.
	AcceptNFTBidCreatorPublicKey        []byte
	AcceptNFTBidBidderPublicKey         []byte
	AcceptNFTBidCreatorRoyaltyNanos     uint64
	AcceptNFTBidCreatorDESORoyaltyNanos uint64
	AcceptNFTBidAdditionalCoinRoyalties []*PublicKeyRoyaltyPair
	AcceptNFTBidAdditionalDESORoyalties []*PublicKeyRoyaltyPair

	// These values are used by Rosetta in order to create input and output
	// operations. They make it so that we don't have to reconnect all txns
	// in order to get these values for NFT bid transactions on Buy Now NFTs.
	NFTBidCreatorPublicKey        []byte
	NFTBidBidderPublicKey         []byte
	NFTBidCreatorRoyaltyNanos     uint64
	NFTBidCreatorDESORoyaltyNanos uint64
	NFTBidAdditionalCoinRoyalties []*PublicKeyRoyaltyPair
	NFTBidAdditionalDESORoyalties []*PublicKeyRoyaltyPair
} 
type MessageKey struct {
	PublicKey   PublicKey
	BlockHeight uint32
	TstampNanos uint64
} 
type MessageEntry struct {
	SenderPublicKey    *PublicKey
	RecipientPublicKey *PublicKey
	EncryptedText      []byte
	// TODO: Right now a sender can fake the timestamp and make it appear to
	// the recipient that she sent messages much earlier than she actually did.
	// This isn't a big deal because there is generally not much to gain from
	// faking a timestamp, and it's still impossible for a user to impersonate
	// another user, which is the important thing. Moreover, it is easy to fix
	// the timestamp spoofing issue: You just need to make it so that the nodes
	// index messages based on block height in addition to on the tstamp. The
	// reason I didn't do it yet is because it adds some complexity around
	// detecting duplicates, particularly if a transaction is allowed to have
	// zero inputs/outputs, which is advantageous for various reasons.
	TstampNanos uint64

	isDeleted bool

	// Indicates message encryption method
	// Version = 3 : message encrypted using rotating keys and group chats.
	// Version = 2 : message encrypted using shared secrets
	// Version = 1 : message encrypted using public key
	Version uint8

	// DeSo V3 Messages fields

	// SenderMessagingPublicKey is the sender's messaging public key that was used
	// to encrypt the corresponding message.
	SenderMessagingPublicKey *PublicKey

	// SenderMessagingGroupKeyName is the sender's key name of SenderMessagingPublicKey
	SenderMessagingGroupKeyName *GroupKeyName

	// RecipientMessagingPublicKey is the recipient's messaging public key that was
	// used to encrypt the corresponding message.
	RecipientMessagingPublicKey *PublicKey

	// RecipientMessagingGroupKeyName is the recipient's key name of RecipientMessagingPublicKey
	RecipientMessagingGroupKeyName *GroupKeyName
} 
type MessagingGroupKey struct {
	OwnerPublicKey PublicKey
	GroupKeyName   GroupKeyName
} 
type MessagingGroupEntry struct {
	// GroupOwnerPublicKey represents the owner public key of the user who created
	// this group. This key is what is used to index the group metadata in the db.
	GroupOwnerPublicKey *PublicKey

	// MessagingPublicKey is the key others will use to encrypt messages. The
	// GroupOwnerPublicKey is used for indexing, but the MessagingPublicKey is the
	// actual key used to encrypt/decrypt messages.
	MessagingPublicKey *PublicKey

	// MessagingGroupKeyName is the name of the messaging key. This is used to identify
	// the message public key. You can pass any 8-32 character string (byte array).
	// The standard Messages V3 key is named "default-key"
	MessagingGroupKeyName *GroupKeyName

	// MessagingGroupMembers is a list of recipients in a group chat. Messaging keys can have
	// multiple recipients, where the encrypted private key of the messaging public key
	// is given to all group members.
	MessagingGroupMembers []*MessagingGroupMember

	// Whether this entry should be deleted when the view is flushed
	// to the db. This is initially set to false, but can become true if
	// we disconnect the messaging key from UtxoView
	isDeleted bool
} 
type MessagingGroupMember struct {
	// GroupMemberPublicKey is the main public key of the group chat member.
	// Importantly, it isn't a messaging public key.
	GroupMemberPublicKey *PublicKey

	// GroupMemberKeyName determines the key of the recipient that the
	// encrypted key is addressed to. We allow adding recipients by their
	// messaging keys. It suffices to specify the recipient's main public key
	// and recipient's messaging key name for the consensus to know how to
	// index the recipient. That's why we don't actually store the messaging
	// public key in the MessagingGroupMember entry.
	GroupMemberKeyName *GroupKeyName

	// EncryptedKey is the encrypted messaging public key, addressed to the recipient.
	EncryptedKey []byte
} 
type ForbiddenPubKeyEntry struct {
	PubKey []byte

	// Whether or not this entry is deleted in the view.
	isDeleted bool
} 
type LikeKey struct {
	LikerPubKey   PkMapKey
	LikedPostHash BlockHash
} 
type LikeEntry struct {
	LikerPubKey   []byte
	LikedPostHash *BlockHash

	// Whether or not this entry is deleted in the view.
	isDeleted bool
} 
type NFTKey struct {
	NFTPostHash  BlockHash
	SerialNumber uint64
} 
type NFTEntry struct {
	LastOwnerPKID              *PKID // This is needed to decrypt unlockable text.
	OwnerPKID                  *PKID
	NFTPostHash                *BlockHash
	SerialNumber               uint64
	IsForSale                  bool
	MinBidAmountNanos          uint64
	UnlockableText             []byte
	LastAcceptedBidAmountNanos uint64

	// If this NFT was transferred to the current owner, it will be pending until accepted.
	IsPending bool

	// If an NFT does not have unlockable content, it can be sold instantly at BuyNowPriceNanos.
	IsBuyNow bool

	// If an NFT is a Buy Now NFT, it can be purchased for this price.
	BuyNowPriceNanos uint64

	// Whether or not this entry is deleted in the view.
	isDeleted bool
} 
type NFTBidKey struct {
	BidderPKID   PKID
	NFTPostHash  BlockHash
	SerialNumber uint64
} 
type NFTBidEntry struct {
	BidderPKID     *PKID
	NFTPostHash    *BlockHash
	SerialNumber   uint64
	BidAmountNanos uint64

	AcceptedBlockHeight *uint32

	// Whether or not this entry is deleted in the view.
	isDeleted bool
} 
type DerivedKeyEntry struct {
	// Owner public key
	OwnerPublicKey PublicKey

	// Derived public key
	DerivedPublicKey PublicKey

	// Expiration Block
	ExpirationBlock uint64

	// Operation type determines if the derived key is
	// authorized or de-authorized.
	OperationType AuthorizeDerivedKeyOperationType

	// Whether or not this entry is deleted in the view.
	isDeleted bool
} 
type DerivedKeyMapKey struct {
	// Owner public key
	OwnerPublicKey PublicKey

	// Derived public key
	DerivedPublicKey PublicKey
} 
type FollowKey struct {
	FollowerPKID PKID
	FollowedPKID PKID
} 
type FollowEntry struct {
	// Note: It's a little redundant to have these in the entry because they're
	// already used as the key in the DB but it doesn't hurt for now.
	FollowerPKID *PKID
	FollowedPKID *PKID

	// Whether or not this entry is deleted in the view.
	isDeleted bool
} 
type DiamondKey struct {
	SenderPKID      PKID
	ReceiverPKID    PKID
	DiamondPostHash BlockHash
} 
type DiamondEntry struct {
	SenderPKID      *PKID
	ReceiverPKID    *PKID
	DiamondPostHash *BlockHash
	DiamondLevel    int64

	// Whether or not this entry is deleted in the view.
	isDeleted bool
} 
type RepostKey struct {
	ReposterPubKey PkMapKey
	// Post Hash of post that was reposted
	RepostedPostHash BlockHash
} 
type RepostEntry struct {
	ReposterPubKey []byte

	// BlockHash of the repost
	RepostPostHash *BlockHash

	// Post Hash of post that was reposted
	RepostedPostHash *BlockHash

	// Whether or not this entry is deleted in the view.
	isDeleted bool
} 
type GlobalParamsEntry struct {
	// The new exchange rate to set.
	USDCentsPerBitcoin uint64

	// The new create profile fee
	CreateProfileFeeNanos uint64

	// The fee to create a single NFT (NFTs with n copies incur n of these fees).
	CreateNFTFeeNanos uint64

	// The maximum number of NFT copies that are allowed to be minted.
	MaxCopiesPerNFT uint64

	// The new minimum fee the network will accept
	MinimumNetworkFeeNanosPerKB uint64
} 
type PostEntryReaderState struct {
	// This is true if the reader has liked the associated post.
	LikedByReader bool

	// The number of diamonds that the reader has given this post.
	DiamondLevelBestowed int64

	// This is true if the reader has reposted the associated post.
	RepostedByReader bool

	// This is the post hash hex of the repost
	RepostPostHashHex string
} 
type PostEntry struct {
	// The hash of this post entry. Used as the ID for the entry.
	PostHash *BlockHash

	// The public key of the user who made the post.
	PosterPublicKey []byte

	// The parent post. This is used for comments.
	ParentStakeID []byte

	// The body of this post.
	Body []byte

	// The PostHash of the post this post reposts
	RepostedPostHash *BlockHash

	// Indicator if this PostEntry is a quoted repost or not
	IsQuotedRepost bool

	// The amount the creator of the post gets when someone stakes
	// to the post.
	CreatorBasisPoints uint64

	// The multiple of the payout when a user stakes to a post.
	// 2x multiple = 200% = 20,000bps
	StakeMultipleBasisPoints uint64

	// The block height when the post was confirmed.
	ConfirmationBlockHeight uint32

	// A timestamp used for ordering messages when displaying them to
	// users. The timestamp must be unique. Note that we use a nanosecond
	// timestamp because it makes it easier to deal with the uniqueness
	// constraint technically (e.g. If one second spacing is required
	// as would be the case with a standard Unix timestamp then any code
	// that generates these transactions will need to potentially wait
	// or else risk a timestamp collision. This complexity is avoided
	// by just using a nanosecond timestamp). Note that the timestamp is
	// an unsigned int as opposed to a signed int, which means times
	// before the zero time are not represented which doesn't matter
	// for our purposes. Restricting the timestamp in this way makes
	// lexicographic sorting based on bytes easier in our database which
	// is one of the reasons we do it.
	TimestampNanos uint64

	// Users can "delete" posts, but right now we just implement this as
	// setting a flag on the post to hide it rather than actually deleting
	// it. This simplifies the implementation and makes it easier to "undelete"
	// posts in certain situations.
	IsHidden bool

	// Counter of users that have liked this post.
	LikeCount uint64

	// Counter of users that have reposted this post.
	RepostCount uint64

	// Counter of quote reposts for this post.
	QuoteRepostCount uint64

	// Counter of diamonds that the post has received.
	DiamondCount uint64

	// The private fields below aren't serialized or hashed. They are only kept
	// around for in-memory bookkeeping purposes.

	// Whether or not this entry is deleted in the view.
	isDeleted bool

	// How many comments this post has
	CommentCount uint64

	// Indicator if a post is pinned or not.
	IsPinned bool

	// NFT info.
	IsNFT                          bool
	NumNFTCopies                   uint64
	NumNFTCopiesForSale            uint64
	NumNFTCopiesBurned             uint64
	HasUnlockable                  bool
	NFTRoyaltyToCreatorBasisPoints uint64
	NFTRoyaltyToCoinBasisPoints    uint64

	// AdditionalNFTRoyaltiesToCreatorsBasisPoints is a map where keys are PKIDs and values are uint64s representing
	// basis points. The user with the PKID specified should receive the basis points specified by the value as a
	// royalty anytime this NFT is sold. This map must not contain the post creator.
	AdditionalNFTRoyaltiesToCreatorsBasisPoints map[PKID]uint64
	// AdditionalNFTRoyaltiesToCoinsBasisPoints is a map where keys are PKIDs and values are uint64s representing
	// basis points. The user with the PKID specified should have the basis points specified as by the value added to
	// the DESO locked in their profile anytime this NFT is sold. This map must not contain the post creator.
	AdditionalNFTRoyaltiesToCoinsBasisPoints map[PKID]uint64

	// ExtraData map to hold arbitrary attributes of a post. Holds non-consensus related information about a post.
	PostExtraData map[string][]byte
} 
type BalanceEntryMapKey struct {
	HODLerPKID  PKID
	CreatorPKID PKID
} 
type BalanceEntry struct {
	// The PKID of the HODLer. This should never change after it's set initially.
	HODLerPKID *PKID
	// The PKID of the creator. This should never change after it's set initially.
	CreatorPKID *PKID

	// How much this HODLer owns of a particular creator coin.
	BalanceNanos uint256.Int

	// Has the hodler purchased any amount of this user's coin
	HasPurchased bool

	// Whether or not this entry is deleted in the view.
	isDeleted bool
} 
type CoinEntry struct {
	// The amount the owner of this profile receives when there is a
	// "net new" purchase of their coin.
	CreatorBasisPoints uint64

	// The amount of DeSo backing the coin. Whenever a user buys a coin
	// from the protocol this amount increases, and whenever a user sells a
	// coin to the protocol this decreases.
	DeSoLockedNanos uint64

	// The number of public keys who have holdings in this creator coin.
	// Due to floating point truncation, it can be difficult to simultaneously
	// reset CoinsInCirculationNanos and DeSoLockedNanos to zero after
	// everyone has sold all their creator coins. Initially NumberOfHolders
	// is set to zero. Once it returns to zero after a series of buys & sells
	// we reset the DeSoLockedNanos and CoinsInCirculationNanos to prevent
	// abnormal bancor curve behavior.
	NumberOfHolders uint64

	// The number of coins currently in circulation. Whenever a user buys a
	// coin from the protocol this increases, and whenever a user sells a
	// coin to the protocol this decreases.
	//
	// It's OK to have a pointer here as long as we *NEVER* manipulate the
	// bigint in place. Instead, we must always do computations of the form:
	//
	// CoinsInCirculationNanos = uint256.NewInt(0).Add(CoinsInCirculationNanos, <other uint256>)
	//
	// This will guarantee that modifying a copy of this struct will not break
	// the original, which is needed for disconnects to work.
	CoinsInCirculationNanos uint256.Int

	// This field keeps track of the highest number of coins that has ever
	// been in circulation. It is used to determine when a creator should
	// receive a "founder reward." In particular, whenever the number of
	// coins being minted would push the number of coins in circulation
	// beyond the watermark, we allocate a percentage of the coins being
	// minted to the creator as a "founder reward."
	//
	// Note that this field doesn't need to be uint256 because it's only
	// relevant for CreatorCoins, which can't exceed math.MaxUint64 in total
	// supply.
	CoinWatermarkNanos uint64

	// If true, DAO coins can no longer be minted.
	MintingDisabled bool

	TransferRestrictionStatus TransferRestrictionStatus
} 
type PublicKeyRoyaltyPair struct {
	PublicKey          []byte
	RoyaltyAmountNanos uint64
} 
type PKIDEntry struct {
	PKID *PKID
	// We add the public key only so we can reuse this struct to store the reverse
	// mapping of pkid -> public key.
	PublicKey []byte

	isDeleted bool
} 
type ProfileEntry struct {
	// PublicKey is the key used by the user to sign for things and generally
	// verify her identity.
	PublicKey []byte

	// Username is a unique human-readable identifier associated with a profile.
	Username []byte

	// Some text describing the profile.
	Description []byte

	// The profile pic string encoded as a link e.g.
	// data:image/png;base64,<data in base64>
	ProfilePic []byte

	// Users can "delete" profiles, but right now we just implement this as
	// setting a flag on the post to hide it rather than actually deleting
	// it. This simplifies the implementation and makes it easier to "undelete"
	// profiles in certain situations.
	IsHidden bool

	// CreatorCoinEntry tracks the information required to buy/sell creator coins on a user's
	// profile. We "embed" it here for convenience so we can access the fields
	// directly on the ProfileEntry object. Embedding also makes it so that we
	// don't need to initialize it explicitly.
	CreatorCoinEntry CoinEntry

	// DAOCoinEntry tracks the information around the DAO coins issued on a user's profile.
	// Note: the following fields are basically ignored for the DAOCoinEntry
	// 1. CreatorBasisPoints
	// 2. DeSoLockedNanos
	// 3. CoinWaterMarkNanos
	DAOCoinEntry CoinEntry

	// Whether or not this entry should be deleted when the view is flushed
	// to the db. This is initially set to false, but can become true if for
	// example we update a user entry and need to delete the data associated
	// with the old entry.
	isDeleted bool
} 
type UtxoType uint8
 
type OperationType uint
 
type TransferRestrictionStatus uint8
 
type UsernameMapKey [100]byte 
type PkMapKey [100]byte 
type GroupKeyName [100]byte 
type UtxoView struct {
	// Utxo data
	NumUtxoEntries              uint64
	UtxoKeyToUtxoEntry          map[UtxoKey]*UtxoEntry
	PublicKeyToDeSoBalanceNanos map[PublicKey]uint64

	// BitcoinExchange data
	NanosPurchased     uint64
	USDCentsPerBitcoin uint64
	GlobalParamsEntry  *GlobalParamsEntry
	BitcoinBurnTxIDs   map[BlockHash]bool

	// Forbidden block signature pubkeys
	ForbiddenPubKeyToForbiddenPubKeyEntry map[PkMapKey]*ForbiddenPubKeyEntry

	// Messages data
	MessageKeyToMessageEntry map[MessageKey]*MessageEntry

	// Messaging group entries.
	MessagingGroupKeyToMessagingGroupEntry map[MessagingGroupKey]*MessagingGroupEntry

	// Postgres stores message data slightly differently
	MessageMap map[BlockHash]*PGMessage

	// Follow data
	FollowKeyToFollowEntry map[FollowKey]*FollowEntry

	// NFT data
	NFTKeyToNFTEntry              map[NFTKey]*NFTEntry
	NFTBidKeyToNFTBidEntry        map[NFTBidKey]*NFTBidEntry
	NFTKeyToAcceptedNFTBidHistory map[NFTKey]*[]*NFTBidEntry

	// Diamond data
	DiamondKeyToDiamondEntry map[DiamondKey]*DiamondEntry

	// Like data
	LikeKeyToLikeEntry map[LikeKey]*LikeEntry

	// Repost data
	RepostKeyToRepostEntry map[RepostKey]*RepostEntry

	// Post data
	PostHashToPostEntry map[BlockHash]*PostEntry

	// Profile data
	PublicKeyToPKIDEntry map[PkMapKey]*PKIDEntry
	// The PKIDEntry is only used here to store the public key.
	PKIDToPublicKey               map[PKID]*PKIDEntry
	ProfilePKIDToProfileEntry     map[PKID]*ProfileEntry
	ProfileUsernameToProfileEntry map[UsernameMapKey]*ProfileEntry

	// Creator coin balance entries
	HODLerPKIDCreatorPKIDToBalanceEntry map[BalanceEntryMapKey]*BalanceEntry

	// DAO coin balance entries
	HODLerPKIDCreatorPKIDToDAOCoinBalanceEntry map[BalanceEntryMapKey]*BalanceEntry

	// Derived Key entries. Map key is a combination of owner and derived public keys.
	DerivedKeyToDerivedEntry map[DerivedKeyMapKey]*DerivedKeyEntry

	// The hash of the tip the view is currently referencing. Mainly used
	// for error-checking when doing a bulk operation on the view.
	TipHash *BlockHash

	Handle   *badger.DB
	Postgres *Postgres
	Params   *DeSoParams
} 
type WyreWalletOrderWebhookPayload struct {
	// referenceId holds the public key of the user who made initiated the wallet order
	ReferenceId  string `json:"referenceId"`
	AccountId    string `json:"accountId"`
	OrderId      string `json:"orderId"`
	OrderStatus  string `json:"orderStatus"`
	TransferId   string `json:"transferId"`
	FailedReason string `json:"failedReason"`
} 
type WyreWalletOrderFullDetails struct {
	Id                      string  `json:"id"`
	CreatedAt               uint64  `json:"createdAt"`
	Owner                   string  `json:"owner"`
	Status                  string  `json:"status"`
	OrderType               string  `json:"orderType"`
	SourceAmount            float64 `json:"sourceAmount"`
	PurchaseAmount          float64 `json:"purchaseAmount"`
	SourceCurrency          string  `json:"sourceCurrency"`
	DestCurrency            string  `json:"destCurrency"`
	TransferId              string  `json:"transferId"`
	Dest                    string  `json:"dest"`
	AuthCodesRequested      bool    `json:"authCodesRequested"`
	ErrorCategory           string  `json:"errorCategory"`
	ErrorCode               string  `json:"errorCode"`
	ErrorMessage            string  `json:"errorMessage"`
	FailureReason           string  `json:"failureReason"`
	AccountId               string  `json:"accountId"`
	PaymentNetworkErrorCode string  `json:"paymentNetworkErrorCode"`
	InternalErrorCode       string  `json:"internalErrorCode"`
} 
type WyreTransferDetails struct {
	Owner              string      `json:"owner"`
	ReversingSubStatus interface{} `json:"reversingSubStatus"`
	Source             string      `json:"source"`
	PendingSubStatus   interface{} `json:"pendingSubStatus"`
	Status             string      `json:"status"`
	ReversalReason     interface{} `json:"reversalReason"`
	CreatedAt          int64       `json:"createdAt"`
	SourceAmount       float64     `json:"sourceAmount"`
	DestCurrency       string      `json:"destCurrency"`
	SourceCurrency     string      `json:"sourceCurrency"`
	StatusHistories    []struct {
		Id           string      `json:"id"`
		TransferId   string      `json:"transferId"`
		CreatedAt    int64       `json:"createdAt"`
		Type         string      `json:"type"`
		StatusOrder  int         `json:"statusOrder"`
		StatusDetail string      `json:"statusDetail"`
		State        string      `json:"state"`
		FailedState  interface{} `json:"failedState"`
	} `json:"statusHistories"`
	BlockchainTx struct {
		Id            string      `json:"id"`
		NetworkTxId   string      `json:"networkTxId"`
		CreatedAt     int64       `json:"createdAt"`
		Confirmations int         `json:"confirmations"`
		TimeObserved  int64       `json:"timeObserved"`
		BlockTime     int64       `json:"blockTime"`
		Blockhash     string      `json:"blockhash"`
		Amount        float64     `json:"amount"`
		Direction     string      `json:"direction"`
		NetworkFee    float64     `json:"networkFee"`
		Address       string      `json:"address"`
		SourceAddress interface{} `json:"sourceAddress"`
		Currency      string      `json:"currency"`
		TwinTxId      interface{} `json:"twinTxId"`
	} `json:"blockchainTx"`
	ExpiresAt     int64       `json:"expiresAt"`
	CompletedAt   int64       `json:"completedAt"`
	CancelledAt   interface{} `json:"cancelledAt"`
	FailureReason interface{} `json:"failureReason"`
	UpdatedAt     int64       `json:"updatedAt"`
	ExchangeRate  float64     `json:"exchangeRate"`
	DestAmount    float64     `json:"destAmount"`
	Fees          struct {
		BTC int     `json:"BTC"`
		USD float64 `json:"USD"`
	} `json:"fees"`
	TotalFees float64     `json:"totalFees"`
	CustomId  string      `json:"customId"`
	Dest      string      `json:"dest"`
	Message   interface{} `json:"message"`
	Id        string      `json:"id"`
} 
type WyreTrackOrderResponse struct {
	TransferId  string  `json:"transferId"`
	FeeCurrency string  `json:"feeCurrency"`
	Fee         float64 `json:"fee"`
	Fees        struct {
		BTC float64 `json:"BTC"`
		USD float64 `json:"USD"`
	} `json:"fees"`
	SourceCurrency           string      `json:"sourceCurrency"`
	DestCurrency             string      `json:"destCurrency"`
	SourceAmount             float64     `json:"sourceAmount"`
	DestAmount               float64     `json:"destAmount"`
	DestSrn                  string      `json:"destSrn"`
	From                     string      `json:"from"`
	To                       interface{} `json:"to"`
	Rate                     float64     `json:"rate"`
	CustomId                 interface{} `json:"customId"`
	Status                   interface{} `json:"status"`
	BlockchainNetworkTx      interface{} `json:"blockchainNetworkTx"`
	Message                  interface{} `json:"message"`
	TransferHistoryEntryType string      `json:"transferHistoryEntryType"`
	SuccessTimeline          []struct {
		StatusDetails string `json:"statusDetails"`
		State         string `json:"state"`
		CreatedAt     int64  `json:"createdAt"`
	} `json:"successTimeline"`
	FailedTimeline []interface{} `json:"failedTimeline"`
	FailureReason  interface{}   `json:"failureReason"`
	ReversalReason interface{}   `json:"reversalReason"`
} 
type WalletOrderQuotationRequest struct {
	SourceAmount   float64
	Country        string
	SourceCurrency string
} 
type WyreWalletOrderQuotationPayload struct {
	SourceCurrency    string `json:"sourceCurrency"`
	Dest              string `json:"dest"`
	DestCurrency      string `json:"destCurrency"`
	AmountIncludeFees bool   `json:"amountIncludeFees"`
	Country           string `json:"country"`
	SourceAmount      string `json:"sourceAmount"`
	WalletType        string `json:"walletType"`
	AccountId         string `json:"accountId"`
} 
type WalletOrderReservationRequest struct {
	SourceAmount   float64
	ReferenceId    string
	Country        string
	SourceCurrency string
} 
type WyreWalletOrderReservationPayload struct {
	SourceCurrency    string   `json:"sourceCurrency"`
	Dest              string   `json:"dest"`
	DestCurrency      string   `json:"destCurrency"`
	Country           string   `json:"country"`
	Amount            string   `json:"amount"`
	ReferrerAccountId string   `json:"referrerAccountId"`
	LockFields        []string `json:"lockFields"`
	RedirectUrl       string   `json:"redirectUrl"`
	ReferenceId       string   `json:"referenceId"`
} 
type GetWyreWalletOrderForPublicKeyRequest struct {
	PublicKeyBase58Check string
	Username             string

	AdminPublicKey string
} 
type GetWyreWalletOrderForPublicKeyResponse struct {
	WyreWalletOrderMetadataResponses []*WyreWalletOrderMetadataResponse
} 
type WyreWalletOrderMetadataResponse struct {
	// Last payload received from Wyre webhook
	LatestWyreWalletOrderWebhookPayload WyreWalletOrderWebhookPayload

	// Track Wallet Order response received based on the last payload received from Wyre Webhook
	LatestWyreTrackWalletOrderResponse *WyreTrackOrderResponse

	// Amount of DeSo that was sent for this WyreWalletOrder
	DeSoPurchasedNanos     uint64
	BitCloutPurchasedNanos uint64 // Deprecated

	// BlockHash of the transaction for sending the DeSo
	BasicTransferTxnHash string

	Timestamp *time.Time
}